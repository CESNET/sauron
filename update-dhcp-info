#!/usr/bin/perl -I/usr/local/sauron
#
# update-dhcp-info  reads dhcpd syslog entries and updates host dhcp_date
#                   field in hosts table (for given server)
#
# Copyright (c) Timo Kokkonen <tjko@iki.fi>  2001-2003.
# $Id$
#
require 5;
use Getopt::Long;
use Time::Local;
use Sauron::DB;
use Sauron::Util;
use Sauron::BackEnd;

my ($PG_DIR,$PG_NAME) = ($0 =~ /^(.*\/)(.*)$/);
$0 = $PG_NAME;

if (-r "/etc/sauron/config") {
  $config_file="/etc/sauron/config";
} elsif (-r "/usr/local/etc/sauron/config") {
  $config_file="/usr/local/etc/sauron/config";
} else {
  die("cannot find config file in /etc/sauron or /usr/local/etc/sauron");
}

do "$config_file" || die("cannot load config: $config_file");

%months = (Jan=>0,Feb=>1,Mar=>2,Apr=>3,May=>4,Jun=>5,
	   Jul=>6,Aug=>7,Sep=>8,Oct=>9,Nov=>10,Dec=>11);

###################################################################

GetOptions("help|h","verbose|v","debug|d");

if ($opt_help || @ARGV < 2) {
  print "syntax: $0 [--help] [--verbose] <servername> <logfile>\n\n";
  print "" if ($opt_help);
  exit(0);
}

$opt_verbose = ($opt_verbose ? 1 : 0);
$opt_debug = ($opt_debug ? 1 : 0);
$servername=$ARGV[0];
$file=$ARGV[1];
$year=(localtime(time))[5];


fatal("cannot read input file '$file'") unless (-r $file);
fatal("DB_CONNECT not defined in configuration!") unless ($DB_CONNECT);
db_connect($DB_CONNECT);

$serverid=get_server_id($servername);
fatal("cannot find server '$servername'") unless ($serverid > 0);
print "Updating server: $servername ($serverid)\n" if ($opt_verbose);

undef @q;
db_query("SELECT MAX(h.dhcp_date) FROM hosts h, zones z " .
	 "WHERE z.server=$serverid AND h.zone=z.id AND dhcp_date > 0;",\@q);
$latest=($q[0][0] > 0 ? $q[0][0] : 0);
$latest_str = localtime($latest);

print "Latest dhcp_date for this server: $latest_str ($latest)\n"
  if ($opt_verbose);


print "Reading logfile..." if ($opt_verbose);

if ($file =~ /\.gz$/) {
  open(FILE,"gzip -dc $file |") || fatal("cannot decompress file: $file");
} else {
  open(FILE,"$file") || fatal("cannot open file: $file");
}

while (<FILE>) {
  next unless /^(\S+)\s+(\d+)\s+(\d+):(\d+):(\d+)\s+(\S+)\s+dhcpd:\s(.*)$/;

  $m=$months{$1}; $d=$2; $hour=$3; $min=$4; $sec=$5; $host=$6; $rest=$7;
  $t=timelocal($sec,$min,$hour,$d,$m,$year);
  $first_date = $t unless (defined $first_date);
  $first_host = $host unless (defined $first_host);
  if (($t+86400) < $first_date) {
    fatal("Log contains new year or time shifts backwards");
  }
  $mac=''; $cmd='';

  if ($rest =~ /^(DHCPDISCOVER|BOOTREQUEST)\s+from\s+(\S+)\s+via\s+(.*)$/) {
    #print "$1 $2 $3\n";
    $cmd=$1;
    $mac="\U$2";
  }
  elsif ($rest =~ /^(DHCPREQUEST)\s+for\s+(\S+)(\s+\((\S+)\))?\s+from\s+(\S+)\s+via\s+(.*)$/) {
    $cmd=$1;
    $mac="\U$5";
    #print "$1 $2 ($4) $5 '$6' : $mac\n";
  }
  elsif ($rest =~ /^(DHCPACK|DHCPNAK)\s+on\s+(\S+)\s+to\s+(\S+)\s+via\s+(.*)$/) {
    $cmd=$1;
    $mac="\U$3";
    #print "$1 $2 $3 '$4'\n";
  }
  elsif ($rest =~ /^(BOOTREPLY)\s+for\s+(\S+)\s+to\s+(\S+)\s+\((\S+)\)\s+via\s+(.*)$/) {
    $cmd=$1;
    $mac="\U$4";
    #print "$1 $2 $3 $4 '$5'\n";
  }


  if ($mac) {
    $mac =~ s/[^A-F0-9]//g;
    next if (length($mac) == 32); # ignore those damn MS RAS requests...
    unless (length($mac)==12) {
      print "$file($.): invalid mac addres found ($mac)\n";
      next;
    }
    #print "$t : $mac\n";
    $hash{$mac}={} unless (defined $hash{$mac});
    $hash{$mac}->{$cmd}=$t;
  }

}

close(FILE);

$hashcount = (keys %hash);
print "done. (found $hashcount different MACs)\n" if ($opt_verbose);

print "Fetching host info from database..." if ($opt_verbose);
undef @q;
db_query("SELECT h.id,h.ether,h.dhcp_date,h.domain FROM hosts h,zones z " .
	 "WHERE z.server=$serverid AND h.zone=z.id AND h.type=1 " .
	 " AND NOT h.ether ISNULL;",\@q);
$c=@q;
print "done. ($c MACs found in database)\n" if ($opt_verbose);

for $i (0..$#q) {
  $mac="\U$q[$i][1]";
  unless (defined $hash{$mac}) {
    $notfounds++;
    next;
  }
  $id=$q[$i][0];
  $date=($q[$i][2] > 0 ? $q[$i][2] : 0);
  $domain=$q[$i][3];
  $t = $hash{$mac}->{DHCPACK} > 0  ?  $hash{$mac}->{DHCPACK}  :  0;
  $t = $hash{$mac}->{BOOTREPLY} if ($hash{$mac}->{BOOTREPLY} > $t);
  unless ($t > $date) {
    print "notupdating: $domain : $t : $date\n" if ($opt_debug);
    $notupdated++;
    next;
  }
  print "match: $domain $id $date : $t\n" if ($opt_debug);
  push @match, [$id,$t];
}

print "$notfounds host(s) not found from database\n",
      "$notupdated hosts(s) info not updated\n" if ($opt_verbose);

$mcount=@match;
unless ($mcount > 0) {
  print "Nothing to do (no records to be updated)\n" if ($opt_verbose);
  exit;
}

print "Updating dhcp_date for $mcount host records..." if ($opt_verbose);

db_begin();
for $i (0..$#match) {
  $id=$match[$i][0];
  $t=$match[$i][1];
  $res=db_exec("UPDATE hosts SET dhcp_date=$t WHERE id=$id;");
  fatal("cannot update record id=$id") if ($res < 0);
}
fatal("cannot commit changes to database") if (db_commit() < 0);

print "done.\n" if ($opt_verbose);

exit 0;

# eof

