#!/usr/bin/perl
#
# sauron - generates BIND/DHCP/printer configuration files from database
#
# Copyright (c) Timo Kokkonen <tjko@iki.fi>  2000,2001.
# $Id$
#
require 5;
use Net::Netmask;

($PG_DIR,$PG_NAME) = ($0 =~ /^(.*\/)(.*)$/);
$0 = $PG_NAME;

do "$PG_DIR/config" || fatal("cannot load config");
do "$PG_DIR/util.pl";
do "$PG_DIR/db.pl";
do "$PG_DIR/back_end.pl";

$bind_conf=0;
$dhcp_conf=0;
$printer_conf=0;

%yes_no_enum = (D=>'',Y=>'yes',N=>'no');
%check_names_enum = (D=>'',W=>'warn',F=>'fail',I=>'ignore');
%zone_type_enum = (M=>'master',S=>'slave',H=>'hint',F=>'forward');

$ZFORMAT = "%-22s %6s %2s  %-6s %s\n";

#@a = (1,2,3);
#@b = (5,6,7);
#@c = (@a , @b);
#print @a . " " . join(",",@a) . "\n";
#print @b . " " . join(",",@b) . "\n";
#print @c . " " . join(",",@c) . "\n";



##############################

for ($i=0; $i < @ARGV; $i++) {
  $argument=$ARGV[$i];
  last unless ($argument =~ /^-\S+$/);

  for ($j=1;$j < length($argument); $j++) {
    $arg=substr($argument,$j,1);

    if ($arg eq 'a') {
      $bind_conf=1; 
      $dhcp_conf=1; 
      $printer_conf=1;
    } 
    elsif ($arg eq 'b') {
      $bind_conf=1;
    } 
    elsif ($arg eq 'd') {
      $dhcp_conf=1;
    } 
    elsif ($arg eq 'p') {
      $printer_conf=1;
    } 
    else {
      print STDERR "$0: unknown command line option '$arg' (ignored)\n";
    }
  }

}

$argc=@ARGV - $i;

if ($argc < 1 || $argc > 2) {
    print "syntax: $0 [-abdp] <servername> [<target directory>]\n";
    exit(1);
}


$servername = $ARGV[$i];
if ($argc > 1) {
	$targetdir = $ARGV[$i+1];
	$targetdir .= "/" unless ($targetdir =~ /\/$/);
} else {
	$targetdir = "./";
}
$user = (getpwuid($<))[0];
$host = `hostname`;
$host =~ s/\n//g;


fatal("target directory is a file! ($targetdir)") if (-f $targetdir);
fatal("target directory does not exists ($targetdir)") if (! -d $targetdir);
fatal("no permissions to target directory!") 
	unless (-r $targetdir && -x $targetdir && -w $targetdir);

print "server name: $servername\n";
print "target directory: $targetdir\n";

chdir($targetdir) || fatal("Cannot change to directory '$targetdir'!");

db_connect();


$serverid = get_server_id($servername);
fatal("Cannot find server '$servername' from database.") if ($serverid < 0);
fatal("Cannot get server record!") if (get_server($serverid,\%server));


$zonelist = get_zone_list($serverid);
#$zonelist2 = get_zone_list(0);
#$zonelist = [@{$zonelist1},@{$zonelist2}];

$zones = @{$zonelist};
print "Server '$servername' has $zones zones.\n";

make_bind() if ($bind_conf);
make_dhcp() if ($dhcp_conf);
make_printcap() if ($printer_conf);

exit;
###########################################################################



sub make_bind() {
  $zones_only=($server{zones_only} eq 't' ? 1 : 0);
  $bind_filename=($zones_only ? 'named.zones':'named.conf');


  print "BIND configuration\n";
  $time_now = gmtime;

  ##################################################
  # named.conf
  print "Generating $bind_filename...\n";

  open(BINDFILE,">$bind_filename") || fatal("Cannot create $bind_filename!");
  print BINDFILE 
    "// $bind_filename -- automagically generated using $0 $VER\n//\n",
    "// created by $user\@$host at $time_now\n//\n";


  #options section
  unless ($zones_only) {
    print BINDFILE "options {\n";
    print BINDFILE "\tdirectory \"$server{'directory'}\";\n"
      if ($server{'directory'} ne '');
    print BINDFILE "\tpid-file \"$server{'pid_file'}\";\n"
      if ($server{'pid_file'} ne '');
    print BINDFILE "\tdump-file \"$server{'dump_file'}\";\n"
      if ($server{'dump_file'} ne '');
    print BINDFILE "\tstats-file \"$server{'stats_file'}\";\n"
      if ($server{'stats_file'} ne '');
    print BINDFILE "\tnamed-xfer \"$server{'named_xfer'}\";\n"
      if ($server{'named_xfer'} ne '');

    $val=$yes_no_enum{$server{nnotify}};
    print BINDFILE "\tnotify $val;\n" if ($val ne '');
    $val=$yes_no_enum{$server{recursion}};
    print BINDFILE "\trecursion $val;\n" if ($val ne '');

    $val=$check_names_enum{$server{checknames_m}};
    print BINDFILE "\tcheck-names master $val;\n" if ($val ne '');
    $val=$check_names_enum{$server{checknames_s}};
    print BINDFILE "\tcheck-names slave $val;\n" if ($val ne '');
    $val=$check_names_enum{$server{checknames_r}};
    print BINDFILE "\tcheck-names response $val;\n" if ($val ne '');

    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=1 AND ref=$serverid;",
	     \@q);
    if (@q > 0) {
      print BINDFILE "\tallow-transfer {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }

    print BINDFILE "};\n";
  }


  #zones section


  # named.root/named.ca
  unless ($server{no_roots} eq 't') {
    $zfile="$server{pzone_path}$server{named_ca}";
    print BINDFILE "\n\nzone \".\" in {\n";
    print BINDFILE "\ttype hint;\n";
    print BINDFILE "\tfile \"$zfile\";\n";
    print BINDFILE "};\n\n\n";

    undef @q;
    db_query("SELECT domain,ttl,type,value FROM root_servers " .
	     "WHERE server=$serverid ORDER BY domain,type,value;",\@q);
    unless (@q > 0) {
      undef @q;
      db_query("SELECT domain,ttl,type,value FROM root_servers " .
	       "WHERE server=-1 ORDER BY domain,type,value;",\@q);
    }
    warn("empty $server{named_ca}") if (@q < 1);
    print "Generating $server{named_ca} file...\n";
    open(ZONEFILE, ">$zfile") || fatal("Cannot create file: $zfile!");
    $time_now=gmtime;
    print ZONEFILE "; $server{named_ca} - automagically generated by $0 $VER\n";
    print ZONEFILE "; created by: $user  $time_now\n";
    print ZONEFILE ";\n;\n";
    for $i (0..$#q) {
      printf ZONEFILE "%-30s  %8d  %-4s  %s\n",
	      $q[$i][0],$q[$i][1],$q[$i][2],$q[$i][3];
    }
    print ZONEFILE ";\n;\n";
    close(ZONEFILE);
  }


  for($loopcounter=0; $loopcounter < $zones; $loopcounter++) {
    $zonename=$$zonelist[$loopcounter][0];
    $zonename =~ s/\.$//g;
    $origin = $zonename . '.';
    $zoneid=$$zonelist[$loopcounter][1];
    #print "zone: $zonename id=$zoneid\n";
    fatal("Cannot get zone record: $zonename (id=$zoneid)!") 
      if (get_zone($zoneid,\%zone));

    $type=$zone_type_enum{$zone{type}};
    fatal("uknown zone type '$zone{type}'!") unless ($type ne '');

    if ($type eq 'master') { $zfile=$server{'pzone_path'}; } 
    elsif ($type eq 'slave') { $zfile=$server{'szone_path'}; }
    else { $zfile=''; }
    $zfile.=$zonename . ".zone";

    print BINDFILE "zone \"$zonename\" $zone{'class'} {\n";
    print BINDFILE "\ttype $type;\n";
    $val=$check_names_enum{$zone{chknames}};
    print BINDFILE "\tcheck-names $val;\n" if ($val ne '');
    $val=$yes_no_enum{$zone{nnotify}};
    print BINDFILE "\tnotify $val;\n" if ($val ne '');
    print BINDFILE "\tfile \"$zfile\";\n"
      if ($type eq 'master' || $type eq 'slave');

    # allow_update
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=2 AND ref=$zoneid;",\@q);
    if (@q > 0) {
      print BINDFILE "\tallow-update {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }
    # allow_query
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=4 AND ref=$zoneid;",\@q);
    if (@q > 0) {
      print BINDFILE "\tallow-query {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }
    # allow_transfer
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=5 AND ref=$zoneid;",\@q);
    if (@q > 0) {
      print BINDFILE "\tallow-transfer {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }
    # also_notify
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=6 AND ref=$zoneid;",
	     \@q);
    if (@q > 0) {
      print BINDFILE "\talso-notify { ";
      for $j (0..(@q-1)) { 
	$ip=$q[$j][0];
	$ip =~ s/\/32$//g;
	print BINDFILE "\t\t$ip;\n";
      }
      print BINDFILE "\t};\n";
    }
    # masters
    if ($type eq 'slave') {
      undef @q;
      db_query("SELECT ip FROM cidr_entries WHERE type=3 AND ref=$zoneid;",
	       \@q);
      if (@q > 0) {
	print BINDFILE "\tmasters { ";
	for $j (0..(@q-1)) { 
	  $ip=$q[$j][0];
	  $ip =~ s/\/32$//g;
	  print BINDFILE "$ip; "; 
	}
	print BINDFILE " };\n";
      }
    }

    print BINDFILE "};\n\n\n";


    next unless ($type eq 'master');
    if ($zone{'dummy'} eq 't') {
      print "Skipping zone creation for dummy zone: $zonename\n";
      next;
    }


    ######################
    # .zone files
    print "Generating zone file: $zfile\n";
    open(ZONEFILE, ">$zfile") || fatal("Cannot create file: $zfile!");
    $time_now=gmtime;
    print ZONEFILE "; zone $zonename - automagically generated by $0 $VER\n";
    print ZONEFILE "; =====" . '=' x length($zonename) . "\n;\n";
    print ZONEFILE "; created by: $user\@$host  $time_now\n";
    print ZONEFILE ";\n;\n";

    $rev=$zone{'reverse'};
    $class="\U$zone{'class'}";
    $class=~s/\s+$//g;
    $TTL=$server{'ttl'};
    $TTL=$zone{'ttl'} if ($zone{ttl} > 0);
    $ttl=$TTL;
    $ttl='' unless ($ttl > 0);
    $serial=new_serial($zone{'serial'});
    fatal("Cannot update zone $zonename serial!")
      if (update_zone({id=>$zoneid,serial=>$serial}));
    $hostname=$server{'hostname'};
    $hostmaster=$zone{'hostmaster'};
    $hostmaster=$server{'hostmaster'} if ($hostmaster eq '');
    fatal("no hostmaster defined either in server nor zone record for: " .
	  "$zonename") if ($hostmaster eq '');
    fatal("server hostname not defined!") if ($hostname eq '');

    print ZONEFILE "; default TTL for this zone:\n",
                   '$TTL ' . $TTL . "\n;\n";

    print ZONEFILE "@\t$ttl\t$class\tSOA\t$hostname $hostmaster (\n";
    print ZONEFILE "\t\t\t\t\t$serial\t; serial number\n" .
                   "\t\t\t\t\t$zone{'refresh'}\t\t; refresh\n" .
		   "\t\t\t\t\t$zone{'retry'}\t\t; retry\n" .
                   "\t\t\t\t\t$zone{'expire'}\t\t; expire\n" .
		   "\t\t\t\t\t$zone{'minimum'}\t\t; minimum\n\t\t\t\t\t)\n";
    print ZONEFILE ";\n; zone nameservers\n;\n";
    undef @q;
    db_query("SELECT ns FROM ns_entries WHERE type=1 AND ref=$zoneid;",\@q);
    foreach $ns (@q) {
      print ZONEFILE "\t\t$class\tNS\t$$ns[0]\n";
    }
    if ($rev eq 'f') {
      print ZONEFILE ";\n; zone mail exchanges\n;\n";
      undef @q;
      db_query("SELECT mx FROM mx_entries WHERE type=1 AND ref=$zoneid;",\@q);
      foreach $mx (@q) {
	print ZONEFILE "\t\t$class\tMX\t$$mx[0]\n";
      }
      print ZONEFILE ";\n; contact info\n;\n";
      undef @q;
      db_query("SELECT txt FROM txt_entries WHERE type=3 AND ref=$serverid;",
	       \@q);
      foreach $txt (@q) {
	print ZONEFILE "\t\t$class\tTXT\t\"$$txt[0]\"\n";
      }
      undef @q;
      db_query("SELECT txt FROM txt_entries WHERE type=1 AND ref=$zoneid;",
	       \@q);
      foreach $txt (@q) {
	print ZONEFILE "\t\t$class\tTXT\t\"$$txt[0]\"\n";
      }

      # zone A records
      undef @q;
      db_query("SELECT ip FROM hosts,rr_a,zones " .
	       "WHERE hosts.zone=zones.id AND rr_a.host=hosts.id AND " .
	       "zones.id=$zoneid AND domain='\@';",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n; zone A record(s)\n;\n";
	for $i (0 .. $#q) {
	  $net = new Net::Netmask($q[$i][0]);
	  print ZONEFILE "\t\t$class\tA\t" . $net->base() . "\n";
	}
      }

    }


    # delegated zones
    undef @q;
    db_query("SELECT a.domain,c.ns FROM hosts a,zones b,ns_entries c " .
	     "WHERE c.ref=a.id AND a.zone=b.id AND c.type=2 AND a.type=2 " .
	     "AND b.id=$zoneid " .
	     "ORDER BY a.domain;",\@q);
    if (@q > 0) {
      print ZONEFILE ";\n;\n; delegated zones\n;\n";
      $domain='';
      for $i (0 .. $#q) {
	print ZONEFILE ";\n" if (($domain ne '') && ($domain ne $q[$i][0]));
	print ZONEFILE "$q[$i][0]" if ($domain ne $q[$i][0]);
	$domain=$q[$i][0];
	$ns=$q[$i][1];
	print ZONEFILE "\t\t$class\tNS\t" . $ns . "\n";
      }
	print ZONEFILE ";\n";
    }



    if ($rev eq 't') {
      # reverse zone

      #print "reversenet " . $zone{'reversenet'} . "\n";
      $rorigin = cidr2arpa($zone{'reversenet'}) . ".";

      undef @q;
      db_query("SELECT a.ip,h.domain,h.ttl,z.name " .
	       "FROM hosts h,zones z,rr_a a " .
	       "WHERE z.server=$serverid AND h.zone=z.id AND a.host=h.id " .
	       " AND a.reverse=true AND a.ip << '$zone{reversenet}' " .
	       "ORDER BY ip;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n; reverse map from zone: $rzone_name\n;\n";
	for $i (0 .. $#q) {
	  $rip=remove_origin(cidr2arpa($q[$i][0]).".",$rorigin);
	  $rzone_name=$q[$i][3];
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl >0);
	  $rdomain=$q[$i][1];
	  if ($rdomain eq '@') {
	    $rdomain = "$rzone_name.";
	  } else {
	    $rdomain .= ".$rzone_name." unless ($rdomain =~ /\.$/);
	  }
	  #print ZONEFILE "$rip\t$ttl\t$class\tPTR\t$rdomain\n";
	  printf ZONEFILE $ZFORMAT, $rip,$ttl,$class,'PTR',$rdomain;
	}
      }

    } else {
      # normal zone

      # glue records needed for delgated zones
      undef @q;
      db_query("SELECT hosts.domain,rr_a.ip,hosts.ttl FROM hosts,zones,rr_a " .
	       "WHERE hosts.zone=zones.id AND hosts.id=rr_a.host " .
	       "AND zones.id=$zoneid AND hosts.type=6 " .
	       "ORDER BY hosts.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n; Glue A records\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $ip=$q[$i][1];
	  $ip =~ s/\/\d{1,2}$//g;
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl > 0);
	  #print ZONEFILE "$domain\t\t$class\tA\t$ip\n";
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$ip;
	}
      }


      # plain MX domains

      undef @q; # entries with mx-templates
      db_query("SELECT h.domain,m.pri,m.mx,h.ttl " .
	       "FROM hosts h,zones z,mx_entries m,mx_templates r " .
	       "WHERE h.zone=z.id AND h.mx=r.id AND m.ref=r.id AND m.type=3 " .
	       " AND h.type=3 AND h.mx > 0 AND z.id=$zoneid " .
	       "ORDER BY h.domain,m.pri;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; MX only domains (using MX-templates)\n;\n";
	$domain='';
	for $i (0 .. $#q) {
	  print ZONEFILE ";\n" if ($domain ne '' && $domain ne $q[$i][0]);
	  $val=($domain ne $q[$i][0] ? $q[$i][0] : '');
	  $domain=$q[$i][0];
	  $ttl=$q[$i][3];
	  $ttl='' unless ($ttl > 0);
	  printf ZONEFILE $ZFORMAT, $val,$ttl,$class,'MX',
	                            "$q[$i][1] $q[$i][2]";
	}
	print ZONEFILE ";\n";
      }
      undef @q; # entries without mx-templates
      db_query("SELECT h.domain,m.pri,m.mx,h.ttl " .
	       "FROM hosts h,zones z,mx_entries m " .
	       "WHERE h.zone=z.id AND m.ref=h.id AND m.type=2 " .
	       " AND h.type=3 AND h.mx=-1 AND z.id=$zoneid " .
	       "ORDER BY h.domain,m.pri;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; MX only domains\n;\n";
	$domain='';
	for $i (0 .. $#q) {
	  print ZONEFILE ";\n" if ($domain ne '' && $domain ne $q[$i][0]);
	  $val=($domain ne $q[$i][0] ? $q[$i][0] : '');
	  $domain=$q[$i][0];
	  $ttl=$q[$i][3];
	  $ttl='' unless ($ttl > 0);
	  printf ZONEFILE $ZFORMAT, $val,$ttl,$class,'MX',
	                            "$q[$i][1] $q[$i][2]";
	}
	print ZONEFILE ";\n";
      }



      ## wks hash
      undef %wkshash;
      undef @q;
      # wks templates
      db_query("SELECT h.domain,w.proto,w.services FROM hosts h,zones z, " .
	             "wks_templates r, wks_entries w " .
	       "WHERE h.zone=z.id AND h.wks=r.id AND w.ref=r.id " .
	       "AND w.type=2 AND z.id=$zoneid AND h.type=1 " .
	       "ORDER BY h.domain, w.proto;",\@q);
      if (@q > 0) {
	$wks_count=@q;
	#print "found $wks_count wks entries!\n";
	for $i (0 .. $#q) {
	  $rec=$wkshash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[]; 
	    $wkshash{$q[$i][0]}=$rec;
	  }
	  $proto=$q[$i][1];
	  $proto=~s/\s+$//g;
	  push @{$wkshash{$q[$i][0]}}, "$proto $q[$i][2]";
	}
      }
      undef %wkshash2;
      undef @q;
      # wks entries (host specific)
      db_query("SELECT h.domain,w.proto,w.services " .
	       "FROM hosts h,zones z,wks_entries w " .
	       "WHERE z.id=$zoneid AND h.zone=z.id AND h.type=1 " .
	       " AND w.type=1 AND w.ref=h.id " .
	       "ORDER BY h.domain,w.proto;",\@q);
      if (@q > 0) {
	for $i (0 .. $#q) {
	  $rec=$wkshash2{$q[$i][0]};
	  if (!$rec) {
	    $rec=[]; 
	    $wkshash2{$q[$i][0]}=$rec;
	  }
	  $proto=$q[$i][1];
	  $proto=~s/\s+$//g;
	  push @{$wkshash2{$q[$i][0]}}, "$proto $q[$i][2]";
	}
      }



      ## mx hash
      undef %mxhash;
      undef @q;
      db_query("SELECT h.domain,m.pri,m.mx FROM hosts h,zones z,mx_templates r, " .
	         "mx_entries m " .
	       "WHERE h.zone=z.id AND h.mx=r.id AND m.ref=r.id AND m.type=3 " .
	       "AND z.id=$zoneid AND h.type=1 " .
	       "ORDER BY h.domain,m.pri,m.mx;",\@q);
      if (@q > 0) {
	$mx_count=@q;
	#print "found $mx_count mx entries!\n";
	for $i (0 .. $#q) {
	  $rec=$mxhash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[];
	    $mxhash{$q[$i][0]}=$rec;
	  }
	  push @{$mxhash{$q[$i][0]}}, "$q[$i][1] $q[$i][2]";
	}
      }
      undef %mxhash2;
      undef @q;
      # mx entries (host specific)
      db_query("SELECT h.domain,m.pri,m.mx " .
	       "FROM hosts h,zones z,mx_entries m " .
	       "WHERE z.id=$zoneid AND h.zone=z.id AND h.type=1 " .
	       " AND m.type=2 AND m.ref=h.id " .
	       "ORDER BY h.domain,m.pri,m.mx;",\@q);
      if (@q > 0) {
	for $i (0 .. $#q) {
	  $rec=$mxhash2{$q[$i][0]};
	  if (!$rec) {
	    $rec=[]; 
	    $mxhash2{$q[$i][0]}=$rec;
	  }
	  push @{$mxhash2{$q[$i][0]}}, "$q[$i][1] $q[$i][2]";
	}
      }


      ## txt hash
      undef %txthash;
      undef @q;
      db_query("SELECT h.domain,t.txt FROM hosts h,zones z,txt_entries t " .
	       "WHERE h.zone=z.id AND t.type=2 AND t.ref=h.id " .
	       "AND h.type=1 AND z.id=$zoneid " .
	       "ORDER BY h.domain;",\@q);
      if (@q > 0) {
	for $i (0 .. $#q) {
	  $rec=$txthash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[];
	    $txthash{$q[$i][0]}=$rec;
	  }
	  push @{$txthash{$q[$i][0]}}, "$q[$i][1]";
	}
      }


      # normal host entries
      undef @q;
      undef %dnames;
      db_query("SELECT hosts.domain,ip,hinfo_hw,hinfo_sw,ttl,huser,dept, " .
	       "location,info " .
	       "FROM hosts,rr_a " .
	       "WHERE hosts.zone=zones.id AND rr_a.host=hosts.id " .
	       "AND zones.id=$zoneid AND hosts.type=1 " .
	       "AND rr_a.forward=true AND hosts.domain <> '\@' " .
	       "ORDER BY rr_a.ip,hosts.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; A records\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $ip=$q[$i][1];
	  $ip =~ s/\/\d\d$//g;
	  $hinfo_hw=$q[$i][2];
	  $hinfo_sw=$q[$i][3];
	  $ttl=$q[$i][4];
	  $ttl='' unless ($ttl > 0);
	  $txt=$txthash{$domain};
	  $wks=$wkshash{$domain};
	  $wks=$wkshash2{$domain} if ($wkshash2{$domain});
	  $mx=$mxhash{$domain};
	  $mx=$mxhash2{$domain} if ($mxhash2{$domain});
	  $info=$q[$i][5];
	  $info.=", " if ($q[$i][5]);
	  $info.=$q[$i][6];
	  $info.=" " if ($q[$i][6]);
	  $info.=$q[$i][7];
	  $info.=", " if ($q[$i][7]);
	  $info.=$q[$i][8];
	  if ($dnames{$domain}) {
	    #error("duplicate A record $ip for $domain ($dnames{$domain}).");
	    printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$ip;
	    print ZONEFILE ";\n";
	    next;
	  }
	  $dnames{$domain}=$ip;
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$ip;
	  printf ZONEFILE $ZFORMAT, '',$ttl,$class,'HINFO',
	    "$hinfo_hw $hinfo_sw"  if ($hinfo_hw ne '' && $hinfo_sw ne '');
	  if ($wks) {
	    for $k (0 .. $#{$wks}) {
	      printf ZONEFILE $ZFORMAT, '',$ttl,$class,'WKS',"$ip $$wks[$k]";
	    }
	  }
	  if ($mx) {
	    for $k (0 .. $#{$mx}) {
	      $$mx[$k] =~ s/\$DOMAIN/$domain/g;
	      printf ZONEFILE $ZFORMAT, '',$ttl,$class,'MX',$$mx[$k];
	    }
	  }
	  for $k (0 .. $#{$txt}) {
	    $val=$$txt[$k];
	    $val =~ s/\"//g;
	    printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',"\"$val\"";
	  }
	  $info =~ s/\"//g;
	  printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',"\"$info\""
	    unless ($info eq '');
	  print ZONEFILE ";\n";
	}
      }


      # aliases (A records)
      undef @q;
      db_query("SELECT a.domain,b.domain,rr_a.ip,a.ttl " .
	       "FROM hosts a, hosts b,zones z, arec_entries r,rr_a " .
	       "WHERE z.id=$zoneid AND a.type=7 AND a.zone=z.id " .
	       " AND r.host=a.id AND b.id=r.arec AND rr_a.host=b.id " .
	       " AND rr_a.forward=true " .
	       "ORDER BY a.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; In-zone aliases (A records)\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $alias=$q[$i][2];
	  $ttl=$q[$i][3];
	  $ttl='' unless ($ttl > 0);
	  $alias =~ s/\/\d{1,2}\s*$//g;
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$alias;
	  printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',
	                   "\"IP alias for $q[$i][1]\"";
	  print ZONEFILE ";\n";
	}
      }

      # aliases (CNAME records)
      undef @q;
      db_query("SELECT a.domain,b.domain,a.ttl FROM hosts a, hosts b,zones " .
	       "WHERE a.zone=zones.id AND zones.id=$zoneid " .
	       "AND a.type=4 AND a.alias=b.id " .
	       "ORDER BY a.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; In-zone aliases (CNAME records)\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl > 0);
	  $alias=$q[$i][1];
	  $alias="$alias.$origin" unless ($alias =~ /\.$/);
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'CNAME',$alias;
	}
      }
      # aliases outside zone
      undef @q;
      db_query("SELECT domain,cname_txt,hosts.ttl FROM hosts,zones " .
	       "WHERE hosts.zone=zones.id AND zones.id=$zoneid " .
	       "AND hosts.type=4 AND hosts.alias=-1 " .
	       "ORDER BY hosts.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; Outside-zone aliases (CNAME records)\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $alias=$q[$i][1];
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl > 0);
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'CNAME',$alias;
	}
      }

    }

    print ZONEFILE ";\n;\n; eof\n";
    close(ZONEFILE);
  }

  print BINDFILE "\n\n// eof\n";
  close(BINDFILE);
}


######################################################################
# DHCP

sub make_dhcp() {
  print "DHCP configuration\n";
  $time_now = gmtime;

  # dhcpd.conf
  print "Generating dhcpd.conf...\n";

  open(DHCPFILE,">dhcpd.conf") || fatal("Cannot create dhcpd.conf!");
  print DHCPFILE "# dhcpd.conf -- automagically generated using $0 $VER\n";
  print DHCPFILE "#               created by $user at $time_now\n#\n";

  # global entries
  undef @q;
  db_query("SELECT d.dhcp FROM dhcp_entries d " .
	   "WHERE d.type=1 AND d.ref=$serverid;",\@q);
  for $i (0..$#q) {
    print DHCPFILE "$q[$i][0];\n";
  }
  print DHCPFILE "\n\n";

  # net/subnet map

  undef @subnets;
  undef @nets;
  db_query("SELECT net,name,id " . 
	   "FROM nets WHERE server=$serverid AND no_dhcp=false " .
	   "AND subnet=false ORDER BY net;",\@nets);
  if (@nets < 1) {
    fatal("No nets, that use DHCP, defined for this server!");
  }
  for $i (0 .. $#nets) {
    $net=$nets[$i][0];
    $netname=$nets[$i][1];
    $netname =~ s/\s+//g;
    print DHCPFILE "shared-network \"$netname\" {\n";
    undef @net_dhcp;
    db_query("SELECT d.dhcp FROM dhcp_entries d " .
	     "WHERE d.type=4 AND d.ref=$nets[$i][2];",\@net_dhcp);
    for $j (0..$#net_dhcp) { print DHCPFILE "\t$net_dhcp[$i][0];\n"; }
    print DHCPFILE "\n";

    #print DHCPFILE "# net: $net\n\n";
    undef @q;
    db_query("SELECT net,id,name FROM nets " .
	     "WHERE server=$serverid AND no_dhcp=false AND subnet=true " .
	     "AND net << '$net' ORDER BY net;",\@q);
    if (@q < 1 ) {
      error("No subnets that use DHCP found");
      push @q, [$net,'',''];
    } else {
      undef @qq;
      db_query("SELECT ip,router FROM hosts,zones,rr_a " .
	       "WHERE hosts.zone=zones.id AND rr_a.host=hosts.id " .
	       "AND zones.server=$serverid AND router>0 " .
	       "AND ip << '$net' " .
	       "ORDER BY ip,router;",\@qq);
      warn("No router interfaces found for net $net!") if (@qq < 1);

      for $j (0 .. $#q) {
	$ssnet = new Net::Netmask($q[$j][0]);
	$snet = $ssnet->base();
        $nmask = $ssnet->mask();
	$dhcpid = $q[$j][1];
	print DHCPFILE "\t# $q[$j][2]\n";
	print DHCPFILE "\tsubnet $snet netmask $nmask {\n";

	$pri=999999; # should be enough 'cos priority range for a router 0-999
	$router='';
	for $k (0 .. $#qq) {
	  if ($ssnet->match($qq[$k][0]) && $pri > $qq[$k][1]) {
	    $pri=$qq[$k][1];
	    $router=$qq[$k][0];
	  }
	}
	unless ($router eq '') {
	  $router =~ s/\/\d{1,2}\s*$//g;
	  print DHCPFILE "\t\toption routers $router;\n";
	} else {
	  print "no router interface found for subnet: $snet $nmask\n";
	}

	undef @qqq;
	db_query("SELECT d.dhcp FROM dhcp_entries d " .
		 "WHERE d.type=4 AND d.ref=$dhcpid;",\@qqq);
	for $k (0..$#qqq) {
	  print DHCPFILE "\t\t$qqq[$k][0];\n";
	}

	print DHCPFILE "\t}\n";
      }
    }

    print DHCPFILE "}\n\n";
  }

  # groups
  print DHCPFILE "# groups\n\n";

  undef @groups;
  db_query("SELECT id,name FROM groups WHERE server=$serverid;",\@groups);
  if (@groups < 1) {
    error("no groups found for this server");
  } 
  else {
    undef @ghosts;
    db_query("SELECT h.grp,h.ether,a.ip,h.domain,z.name,h.id " .
	     "FROM hosts h, zones z, rr_a a " .
	     "WHERE h.zone=z.id AND a.host=h.id AND h.type=1 " .
	     "AND h.ether NOTNULL AND z.server=$serverid AND a.forward=true " .
	     "AND h.grp>-1 " .
	     "ORDER BY a.ip;",\@ghosts);
    if (@ghosts > 0) {
      for $i (0.. $#groups) {
	$gid=$groups[$i][0];
	$group=$groups[$i][1];
	# $dhcp=db_decode_list_str($groups[$i][2]);
	print DHCPFILE "group {  # $group\n";
	undef @qqq;
	db_query("SELECT d.dhcp FROM dhcp_entries d " .
		 "WHERE d.type=5 AND d.ref=$gid;",\@qqq);
	for $k (0..$#qqq) {
	  $qqq[$k][0] =~ s/\\"/"/g;
	  print DHCPFILE "\t$qqq[$k][0];\n";
	}
	print DHCPFILE "\t\n";

	for $j (0 .. $#nets) {
	  $net=new Net::Netmask($nets[$j][0]);
	  print DHCPFILE "\t# net: " .$net->desc() . "\n";
	  for $k (0 .. $#ghosts) {
	    if ($ghosts[$k][0]==$gid && $net->match($ghosts[$k][2]) ) {
	      $host=$ghosts[$k][3];
	      $host.=".$ghosts[$k][4]" unless ($host =~ /\.$/);
	      $ip=$ghosts[$k][2];
	      $ip =~ s/\/\d{1,2}\s*$//g;
	      $ether=dhcpether($ghosts[$k][1]);
	      #$dhcp=db_decode_list_str($ghosts[$k][5]);
	      $dhcpid=$ghosts[$k][5];
	      if ($ethers{$ether}>0) {
		error("dublicate interface $ip for $ether ($host) ignored");
		next;
	      }
	      $ethers{$ether}++;
	      print DHCPFILE "\thost $host {\n";
	      print DHCPFILE "\t\tfixed-address $ip;\n";
	      print DHCPFILE "\t\thardware ethernet $ether;\n";
	      undef @qqq;
	      db_query("SELECT d.dhcp FROM dhcp_entries d " .
		       "WHERE d.type=3 AND d.ref=$dhcpid;",\@qqq);
	      for $l (0..$#qqq) {
		$qqq[$l][0] =~ s/\\"/"/g;
		print DHCPFILE "\t\t$qqq[$l][0];\n";
	      }
	      print DHCPFILE "\t}\n";
	    }
	  }
	}
	print DHCPFILE "}\n\n";
      }
    } else {
      print "no hosts found for any groups!";
    }
  }

  # not grouped hosts...
  print DHCPFILE "\n# hosts not in any group\n\n";
  undef @ghosts;
  db_query("SELECT h.grp,h.ether,a.ip,h.domain,z.name,h.id " .
	   "FROM hosts h, zones z, rr_a a " .
	   "WHERE h.zone=z.id AND a.host=h.id AND h.type=1 " .
	   "AND h.ether NOTNULL AND z.server=$serverid AND a.forward=true " .
	   "AND h.grp<0 " .
	   "ORDER BY a.ip;",\@ghosts);
  if (@ghosts > 0 ) {
    for $j (0 .. $#nets) {
      $net=new Net::Netmask($nets[$j][0]);
      print DHCPFILE "# net: " .$net->desc() . "\n";
      for $k (0 .. $#ghosts) {
	if ($net->match($ghosts[$k][2]) ) {
	  $host=$ghosts[$k][3];
	  $host.=".$ghosts[$k][4]" unless ($host =~ /\.$/);
	  $ip=$ghosts[$k][2];
	  $ip =~ s/\/\d{1,2}\s*$//g;
	  $ether=dhcpether($ghosts[$k][1]);
	  #$dhcp=db_decode_list_str($ghosts[$k][5]);
	  $dhcpid=$ghosts[$k][5];
	  if ($ethers{$ether}>0) {
	    error("dublicate interface $ip for $ether ($host) ignored");
	    next;
	  }
	  $ethers{$ether}++;
	  print DHCPFILE "host $host {\n";
	  print DHCPFILE "\tfixed-address $ip;\n";
	  print DHCPFILE "\thardware ethernet $ether;\n";
	  undef @qqq;
	  db_query("SELECT d.dhcp FROM dhcp_entries d " .
		       "WHERE d.type=3 AND d.ref=$dhcpid;",\@qqq);
	  for $l (0..$#qqq) {
	    $qqq[$l][0] =~ s/\\"/"/g;
	    print DHCPFILE "\t$qqq[$l][0];\n";
	  }
	  print DHCPFILE "}\n";
	}
      }
    }
  }

  undef @ghosts;
  undef %ethers;
  print DHCPFILE "\n# eof\n";
  close(DHCPFILE);
}


######################################################################
# printcap

sub make_printcap() {
  print "PRINTER configuration\n";
  $time_now = gmtime;

  # printcap
  print "Generating printcap...\n";

  
  open(PCAPFILE,">printcap") || fatal("Cannot create printcap!");
  print PCAPFILE "# printcap -- automagically generated using $0 $VER\n";
  print PCAPFILE "#             created by $user at $time_now\n#\n";


  print PCAPFILE "# eof\n";
  close(PCAPFILE);
}


############################################################################

sub dhcpether($) {
  my ($e) = @_;

  $e="\L$e";
  if ($e =~ /(..)(..)(..)(..)(..)(..)/) {
    return "$1:$2:$3:$4:$5:$6";
  }

  return "00:00:00:00:00:00";
}

sub error($) {
  my ($msg) = @_;

  print STDERR "$0: $msg\n";
}

sub fatal($) {
  my ($msg) = @_;
  error($msg);
  exit 1;
}




