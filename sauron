#!/usr/bin/perl
#
# sauron - generates BIND/DHCP/printer configuration files from database
#
# Copyright (c) Timo Kokkonen <tjko@iki.fi>  2000,2001.
# $Id$
#
require 5;
use Net::Netmask;
use Getopt::Long;

($PG_DIR,$PG_NAME) = ($0 =~ /^(.*\/)(.*)$/);
$0 = $PG_NAME;

if (-r "/etc/sauron/config") {
  $config_file="/etc/sauron/config";
} elsif (-r "/usr/local/etc/sauron/config") {
  $config_file="/usr/local/etc/sauron/config"; 
} else {
  die("cannot find config file in /etc/sauron or /usr/local/etc/sauron");
}

do "$config_file" || die("cannot load config: $config_file");
do "$PG_DIR/util.pl";
do "$PG_DIR/db.pl";
do "$PG_DIR/back_end.pl";

$bind_conf=0;
$dhcp_conf=0;
$printer_conf=0;

$dhcp2_mode = ($SAURON_DHCP2_MODE ? 1 : 0);

%yes_no_enum = (D=>'',Y=>'yes',N=>'no');
%check_names_enum = (D=>'',W=>'warn',F=>'fail',I=>'ignore');
%zone_type_enum = (M=>'master',S=>'slave',H=>'hint',F=>'forward');

$ZFORMAT = "%-22s %6s %2s  %-6s %s\n";

##############################

$result=GetOptions("help|h","all|a","bind|b","dhcp|d","printer|p",
		  "updateserial","noupdateserial","verbose","dhcp2","clean");

if ($opt_help || @ARGV < 1 || $result < 1) {
    print "syntax: $0 [--help] [options] <servername> [<target directory>]\n";
    print "\n\toptions:\n",
      "\t--all            generate all configuration files\n",
      "\t--bind           generate BIND (named) configuration files\n",
      "\t--dhcp           generate DHCP (dhcpd) configuration files\n",
      "\t--clean          cleanup expired records and vacuum database\n",
      "\t--printer        generate PRINTER (lpd) configuration files\n\n",
      "\t--updateserial   force serial update on master zones\n\n",
      "\t--dhcp2          enable DHCPv2 compatibilty mode\n\n";
    exit(1);
}


$dhcp_conf=1 if ($opt_dhcp || $opt_all);
$bind_conf=1 if ($opt_bind || $opt_all);
$printer_conf=1 if ($opt_printer || $opt_all);
$verbose=($opt_verbose ? 1 : 0);
$dhcp2_mode=1 if ($opt_dhcp2);

$servername = $ARGV[0];
if (@ARGV > 1) {
	$targetdir = $ARGV[1];
	$targetdir .= "/" unless ($targetdir =~ /\/$/);
} else {
	$targetdir = "./";
}
$user = (getpwuid($<))[0];
$host = `hostname`;
$host =~ s/\n//g;


fatal("target directory is a file! ($targetdir)") if (-f $targetdir);
fatal("target directory does not exists ($targetdir)") if (! -d $targetdir);
fatal("no permissions to target directory!") 
	unless (-r $targetdir && -x $targetdir && -w $targetdir);

print "server name: $servername\n";
print "target directory: $targetdir\n";

print "DHCP v2 compatibility mode enabled\n" if ($dhcp2_mode);
chdir($targetdir) || fatal("Cannot change to directory '$targetdir'!");

db_connect();

$time_now_ticks = time;


$serverid = get_server_id($servername);
fatal("Cannot find server '$servername' from database.") if ($serverid < 0);
fatal("Cannot get server record!") if (get_server($serverid,\%server));

$dhcp_auto_domainnames = ($server{dhcp_flags} & 0x01 ? 1 : 0);


$zonelist = get_zone_list($serverid);
#$zonelist2 = get_zone_list(0);
#$zonelist = [@{$zonelist1},@{$zonelist2}];

$zones = @{$zonelist};
print "Server '$servername' has $zones zones.\n";

clean_up() if ($opt_clean);
make_bind() if ($bind_conf);
make_dhcp() if ($dhcp_conf);
make_printcap() if ($printer_conf);

exit;
###########################################################################

sub clean_up() {
  my(@q,$i,$count,$t);

  print "Cleaning up database...\n";

  $t=$time_now_ticks - (86400 * 30);

  db_query("SELECT h.id,h.expiration,h.domain,h.type " .
	   "FROM hosts h, zones z " .
	   "WHERE z.server=$serverid AND h.zone=z.id " .
	   " AND h.expiration > 0 AND h.expiration < $time_now_ticks " .
	   "ORDER BY h.expiration",\@q);
  error(db_errormsg()) if (db_errormsg());
  $count=@q;

  for $i (0..$#q) {
    print "Purging: $q[$i][2] (id=$q[$i][0])   ".localtime($q[$i][1])."\n"
      if ($verbose);
    error("Cannot remove host: $q[$i][2] (id=$q[$i][0])")
      if (delete_host($q[$i][0]) < 0);
  }
  print "$count expired host(s) purged.\n";

  # error("Database vacuum failed!") if (db_vacuum() < 0);
}


sub make_bind() {
  $zones_only=($server{zones_only} eq 't' ? 1 : 0);
  $bind_filename=($zones_only ? 'named.zones':'named.conf');


  print "BIND configuration\n";
  $time_now = localtime;

  ##################################################
  # named.conf
  print "Generating $bind_filename...\n";

  open(BINDFILE,">$bind_filename") || fatal("Cannot create $bind_filename!");
  print BINDFILE 
    "// $bind_filename -- automagically generated using $0 $VER\n//\n",
    "// created by $user\@$host at $time_now\n//\n";


  #options section
  unless ($zones_only) {
    print BINDFILE "options {\n";
    print BINDFILE "\tdirectory \"$server{'directory'}\";\n"
      if ($server{'directory'} ne '');
    print BINDFILE "\tpid-file \"$server{'pid_file'}\";\n"
      if ($server{'pid_file'} ne '');
    print BINDFILE "\tdump-file \"$server{'dump_file'}\";\n"
      if ($server{'dump_file'} ne '');
    print BINDFILE "\tstats-file \"$server{'stats_file'}\";\n"
      if ($server{'stats_file'} ne '');
    print BINDFILE "\tnamed-xfer \"$server{'named_xfer'}\";\n"
      if ($server{'named_xfer'} ne '');

    $val=$yes_no_enum{$server{nnotify}};
    print BINDFILE "\tnotify $val;\n" if ($val ne '');
    $val=$yes_no_enum{$server{recursion}};
    print BINDFILE "\trecursion $val;\n" if ($val ne '');

    $val=$check_names_enum{$server{checknames_m}};
    print BINDFILE "\tcheck-names master $val;\n" if ($val ne '');
    $val=$check_names_enum{$server{checknames_s}};
    print BINDFILE "\tcheck-names slave $val;\n" if ($val ne '');
    $val=$check_names_enum{$server{checknames_r}};
    print BINDFILE "\tcheck-names response $val;\n" if ($val ne '');

    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=1 AND ref=$serverid " .
	     "ORDER BY ip;",
	     \@q);
    error(db_errormsg()) if (db_errormsg());
    if (@q > 0) {
      print BINDFILE "\tallow-transfer {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }

    print BINDFILE "};\n";
  }


  #zones section


  # named.root/named.ca
  unless ($server{no_roots} eq 't') {
    $zfile="$server{pzone_path}$server{named_ca}";
    print BINDFILE "\n\nzone \".\" in {\n";
    print BINDFILE "\ttype hint;\n";
    print BINDFILE "\tfile \"$zfile\";\n";
    print BINDFILE "};\n\n\n";

    undef @q;
    db_query("SELECT domain,ttl,type,value FROM root_servers " .
	     "WHERE server=$serverid ORDER BY domain,type,value;",\@q);
    error(db_errormsg()) if (db_errormsg());
    unless (@q > 0) {
      undef @q;
      db_query("SELECT domain,ttl,type,value FROM root_servers " .
	       "WHERE server=-1 ORDER BY domain,type,value;",\@q);
    }
    fatal("empty $server{named_ca}") if (@q < 1);
    print "Generating $server{named_ca} file...\n";
    open(ZONEFILE, ">$zfile") || fatal("Cannot create file: $zfile!");
    $time_now=localtime;
    print ZONEFILE "; $server{named_ca} - automagically generated by $0 $VER\n";
    print ZONEFILE "; created by: $user  $time_now\n";
    print ZONEFILE ";\n;\n";
    for $i (0..$#q) {
      printf ZONEFILE "%-30s  %8d  %-4s  %s\n",
	      $q[$i][0],$q[$i][1],$q[$i][2],$q[$i][3];
    }
    print ZONEFILE ";\n;\n";
    close(ZONEFILE);
  }


  for($loopcounter=0; $loopcounter < $zones; $loopcounter++) {
    $zonename=$$zonelist[$loopcounter][0];
    $zonename =~ s/\.$//g;
    $origin = $zonename . '.';
    $zoneid=$$zonelist[$loopcounter][1];
    #print "zone: $zonename id=$zoneid\n";
    fatal("Cannot get zone record: $zonename (id=$zoneid)!") 
      if (get_zone($zoneid,\%zone));

    $type=$zone_type_enum{$zone{type}};
    fatal("uknown zone type '$zone{type}'!") unless ($type ne '');

    if ($type eq 'master') { $zfile=$server{'pzone_path'}; } 
    elsif ($type eq 'slave') { $zfile=$server{'szone_path'}; }
    else { $zfile=''; }
    $zfile.=$zonename . ".zone";

    print BINDFILE "zone \"$zonename\" $zone{'class'} {\n";
    print BINDFILE "\ttype $type;\n";
    $val=$check_names_enum{$zone{chknames}};
    print BINDFILE "\tcheck-names $val;\n" if ($val ne '');
    $val=$yes_no_enum{$zone{nnotify}};
    print BINDFILE "\tnotify $val;\n" if ($val ne '');
    print BINDFILE "\tfile \"$zfile\";\n"
      if ($type eq 'master' || $type eq 'slave');

    # allow_update
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=2 AND ref=$zoneid " .
	     "ORDER BY ip;",\@q);
    error(db_errormsg()) if (db_errormsg());
    if (@q > 0) {
      print BINDFILE "\tallow-update {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }
    # allow_query
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=4 AND ref=$zoneid " .
	     "ORDER BY ip;",\@q);
    error(db_errormsg()) if (db_errormsg());
    if (@q > 0) {
      print BINDFILE "\tallow-query {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }
    # allow_transfer
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=5 AND ref=$zoneid " .
	     "ORDER BY ip;",\@q);
    error(db_errormsg()) if (db_errormsg());
    if (@q > 0) {
      print BINDFILE "\tallow-transfer {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }
    # also_notify
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=6 AND ref=$zoneid " .
	     "ORDER BY ip;",
	     \@q);
    error(db_errormsg()) if (db_errormsg());
    if (@q > 0) {
      print BINDFILE "\talso-notify {\n";
      for $j (0..(@q-1)) {
	$ip=$q[$j][0];
	$ip =~ s/\/32$//g;
	print BINDFILE "\t\t$ip;\n";
      }
      print BINDFILE "\t};\n";
    }
    # masters
    if ($type eq 'slave') {
      undef @q;
      db_query("SELECT ip FROM cidr_entries WHERE type=3 AND ref=$zoneid " .
	       "ORDER BY ip;",
	       \@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print BINDFILE "\tmasters { ";
	for $j (0..(@q-1)) {
	  $ip=$q[$j][0];
	  $ip =~ s/\/32$//g;
	  print BINDFILE " $ip; "; 
	}
	print BINDFILE " };\n";
      }
    }

    print BINDFILE "};\n\n\n";


    next unless ($type eq 'master');
    if ($zone{'dummy'} eq 't') {
      print "Skipping zone creation for dummy zone: $zonename\n";
      next;
    }


    ######################
    # .zone files
    print "Generating zone file: $zfile\n";
    open(ZONEFILE, ">$zfile") || fatal("Cannot create file: $zfile!");
    $time_now=localtime;
    print ZONEFILE "; zone $zonename - automagically generated by $0 $VER\n";
    print ZONEFILE "; =====" . '=' x length($zonename) . "\n;\n";
    print ZONEFILE "; created by: $user\@$host  $time_now\n";
    print ZONEFILE ";\n;\n";

    $rev=$zone{'reverse'};
    $class="\U$zone{'class'}";
    $class=~s/\s+$//g;
    $TTL=$server{'ttl'};
    $TTL=$zone{'ttl'} if ($zone{ttl} > 0);
    $ttl='';
    $ttl_refresh = ($zone{refresh} ? $zone{refresh} : $server{refresh});
    $ttl_retry = ($zone{retry} ? $zone{retry} : $server{retry});
    $ttl_expire = ($zone{expire} ? $zone{expire} : $server{expire});
    $ttl_minimum = ($zone{minimum} ? $zone{minimum} : $server{minimum});

    undef @q;
    db_query("SELECT MAX(h.mdate) FROM hosts h WHERE h.zone=$zoneid;",\@q);
    $hosts_mdate = ($q[0][0] > 0 ? $q[0][0] : 0);
    undef @q;
    db_query("SELECT MAX(h.cdate) FROM hosts h WHERE h.zone=$zoneid;",\@q);
    $hosts_mdate = $q[0][0] if ($q[0][0] > $hosts_mdate);

    $serial=$zone{serial};
    $serial_date=($zone{serial_date} > 0 ? $zone{serial_date} : 0);
    if ( ($server{mdate} > $serial_date) ||
	 ($zone{mdate} > $serial_date) ||
	 ($hosts_mdate > $serial_date) || $opt_updateserial ) {
      #print "server: $server{mdate}, zone: $zone{mdate} ",
      #	    "hosts: $hosts_mdate  - $serial_date\n";
      $serial=new_serial($serial);
      $serial_date=time;
      unless ($opt_noupdateserial) {
	print "Updating serial $zone{serial} --> $serial\n";
	fatal("Cannot update zone $zonename serial!")
	  if (update_record('zones',{id=>$zoneid,serial=>$serial,
				     serial_date=>$serial_date}));
      }
    }
    $hostname=$server{'hostname'};
    $hostmaster=$zone{'hostmaster'};
    $hostmaster=$server{'hostmaster'} if ($hostmaster eq '');
    fatal("no hostmaster defined either in server nor zone record for: " .
	  "$zonename") if ($hostmaster eq '');
    fatal("server hostname not defined!") if ($hostname eq '');
    fatal("no TTL defined!") unless ($TTL > 0);

    print ZONEFILE '$TTL ' . "$TTL\t; default TTL for this zone\n;\n";
    print ZONEFILE '$ORIGIN ' . "$zonename.\n;\n";

    print ZONEFILE "@\t$ttl\t$class\tSOA\t$hostname $hostmaster (\n";
    print ZONEFILE "\t\t\t\t\t $serial\t; serial number\n" .
                   "\t\t\t\t\t $ttl_refresh\t\t; refresh\n" .
		   "\t\t\t\t\t $ttl_retry\t\t; retry\n" .
                   "\t\t\t\t\t $ttl_expire\t\t; expire\n" .
		   "\t\t\t\t\t $ttl_minimum\t\t; minimum\n\t\t\t\t\t)\n";
    print ZONEFILE ";\n; zone nameservers\n;\n";
    undef @q;
    db_query("SELECT ns FROM ns_entries WHERE type=1 AND ref=$zoneid;",\@q);
    error(db_errormsg()) if (db_errormsg());
    foreach $ns (@q) {
      #print ZONEFILE "\t\t$class\tNS\t$$ns[0]\n";
      printf ZONEFILE $ZFORMAT, '',$ttl,$class,'NS',$$ns[0];
    }
    if ($rev eq 'f') {
      undef @q;
      db_query("SELECT pri,mx FROM mx_entries WHERE type=1 AND ref=$zoneid " .
	       "ORDER BY pri,mx;",\@q);
      error(db_errormsg()) if (db_errormsg());
      print ZONEFILE ";\n; zone mail exchanges\n;\n" if (@q > 0);
      foreach $mx (@q) {
	#print ZONEFILE "\t\t$class\tMX\t$$mx[0]\n";
	printf ZONEFILE $ZFORMAT, '',$ttl,$class,'MX',"$$mx[0] $$mx[1]";
      }
      undef @q;
      db_query("SELECT txt FROM txt_entries WHERE type=3 AND ref=$serverid;",
	       \@q);
      error(db_errormsg()) if (db_errormsg());
      print ZONEFILE ";\n; contact info (server)\n;\n" if (@q > 0);
      foreach $txt (@q) {
	#print ZONEFILE "\t\t$class\tTXT\t\"$$txt[0]\"\n";
	printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',$$txt[0];
      }
      undef @q;
      db_query("SELECT txt FROM txt_entries WHERE type=1 AND ref=$zoneid;",
	       \@q);
      error(db_errormsg()) if (db_errormsg());
      print ZONEFILE ";\n; contact info (zone)\n;\n" if (@q > 0);
      foreach $txt (@q) {
	#print ZONEFILE "\t\t$class\tTXT\t\"$$txt[0]\"\n";
	$val=$$txt[0];
	$val =~ s/\"//g;
	printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',"\"$$txt[0]\"";
      }

      # zone A records
      undef @q;
      db_query("SELECT a.ip,h.ttl FROM hosts h,a_entries a,zones z " .
	       "WHERE h.zone=z.id AND a.host=h.id AND " .
	       "z.id=$zoneid AND h.domain='\@';",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n; zone A record(s)\n;\n";
	for $i (0 .. $#q) {
	  #$net = new Net::Netmask($q[$i][0]);
	  $ip=$q[$i][0];
	  $ip =~ s/\/32$//;
	  $ttl=$q[$i][1];
	  $ttl='' unless ($ttl > 0);
	  #print ZONEFILE "\t\t$class\tA\t" . $net->base() . "\n";
	  printf ZONEFILE $ZFORMAT, '',$ttl,$class,'A',$ip;
	}
      }

    }


    # delegated zones
    undef @cnamedelegs;
    undef %delegnets;
    undef @q;
    $delegation_mask='';
    db_query("SELECT a.domain,c.ns,a.ttl FROM hosts a,zones b,ns_entries c " .
	     "WHERE c.ref=a.id AND a.zone=b.id AND c.type=2 AND a.type=2 " .
	     "AND b.id=$zoneid " .
	     "ORDER BY a.domain,c.ns;",\@q);
    error(db_errormsg()) if (db_errormsg());
    if (@q > 0) {
      print ZONEFILE ";\n;\n; delegated zones\n;\n";
      $domain='';
      for $i (0 .. $#q) {
	print ZONEFILE ";\n" if (($domain ne '') && ($domain ne $q[$i][0]));
	$val = ($domain ne $q[$i][0] ? $q[$i][0] : '');
	if ($rev eq 't') {
	  if ($val =~ /^(\d+)-(\d+)\.(\S+)$/) {
	    push @cnamedelegs, [$1,$2,$3,$val];
	    #print ZONEFILE "; special (CNAME hack) delegation:\n";
	  } elsif ($val) {
	    $dnet = arpa2cidr("$val.$zonename");
	    fatal("invalid reverse delegation '$val'")
	      if ($dneg eq '0.0.0.0/0');
	    #print "dnet: $dnet\n";
	    $net = new Net::Netmask($dnet);
	    $net->storeNetblock(\%delegnets);
	  }
	}
	$domain=$q[$i][0];
	$ns=$q[$i][1];
	$ttl=$q[$i][2];
	$ttl='' unless ($ttl > 0);
	if ($val) {
	  $delegation_mask .= '|' if ($delegation_mask);
	  $delegation_mask .= $val;
	}
	printf ZONEFILE $ZFORMAT, $val,$ttl,$class,'NS',$ns;
      }
	print ZONEFILE ";\n";
    }

    $delegation_mask =~ s/\./\\\./g;
    #print "dmask='$delegation_mask'\n";

    if ($rev eq 't') {
      # reverse zone

      # generate CNAMEs for delegations for small nets
      if (@cnamedelegs > 0) {
	print ZONEFILE ";\n; CNAME maps for special delegations\n";
	for $i (0..$#cnamedelegs) {
	  $start=$cnamedelegs[$i][0];
	  $end=$cnamedelegs[$i][1];
	  $rest=$cnamedelegs[$i][2];
	  $domain=$cnamedelegs[$i][3];
	  print ZONEFILE ";\n; $domain:\n";
	  for $j ($start..$end) {
	    printf ZONEFILE $ZFORMAT, "$j.$rest",'',$class,'CNAME',
	                              "$j.$domain.$zonename.";
	  }
	  print ZONEFILE ";\n";
	}
	print ZONEFILE ";\n";
      }


      # generate reverse map for master reverse zones

      #print "reversenet " . $zone{'reversenet'} . "\n";
      $rorigin = cidr2arpa($zone{'reversenet'}) . ".";

      undef @q;
      db_query("SELECT a.ip,h.domain,h.ttl,z.name,h.expiration " .
	       "FROM hosts h,zones z,a_entries a " .
	       "WHERE z.server=$serverid AND h.zone=z.id AND h.type=1 " .
	       " AND a.host=h.id " .
	       " AND a.reverse=true AND a.ip << '$zone{reversenet}' " .
	       "ORDER BY ip;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n; reverse map for: $zone{reversenet}\n;\n";
	for $i (0 .. $#q) {
	  if (findNetblock($q[$i][0],\%delegnets)) {
	    #print "SKIP: $q[$i][0]\n";
	    next;
	  }
	  if (($q[$i][4] > 0) && ($q[$i][4] < $time_now_ticks)) {
	    #print "Skipping expired host reverse: $q[$i][0]\n";
	    next;
	  }
	  $rip=remove_origin(cidr2arpa($q[$i][0]).".",$rorigin);
	  $rzone_name=$q[$i][3];
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl >0);
	  $rdomain=$q[$i][1];
	  if ($rdomain eq '@') {
	    $rdomain = "$rzone_name.";
	  } else {
	    $rdomain .= ".$rzone_name." unless ($rdomain =~ /\.$/);
	  }
	  printf ZONEFILE $ZFORMAT, $rip,$ttl,$class,'PTR',$rdomain;
	}
      }

    } else {
      # normal zone

      # glue records needed for delgated zones
      undef @q;
      db_query("SELECT hosts.domain,a_entries.ip,hosts.ttl " .
	       "FROM hosts,zones,a_entries " .
	       "WHERE hosts.zone=zones.id AND hosts.id=a_entries.host " .
	       "AND zones.id=$zoneid AND hosts.type=6 " .
	       "ORDER BY hosts.domain;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n; Glue A records\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $ip=$q[$i][1];
	  $ip =~ s/\/\d{1,2}$//g;
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl > 0);
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$ip;
	}
      }

      # plain MX domains

      undef @q; # entries with mx-templates
      db_query("SELECT h.domain,m.pri,m.mx,h.ttl " .
	       "FROM hosts h,zones z,mx_entries m,mx_templates r " .
	       "WHERE h.zone=z.id AND h.mx=r.id AND m.ref=r.id AND m.type=3 " .
	       " AND h.type=3 AND h.mx > 0 AND z.id=$zoneid " .
	       "ORDER BY h.domain,m.pri,m.mx;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n;\n; MX only domains (using MX-templates)\n;\n";
	$domain='';
	for $i (0 .. $#q) {
	  print ZONEFILE ";\n" if ($domain ne '' && $domain ne $q[$i][0]);
	  $val=($domain ne $q[$i][0] ? $q[$i][0] : '');
	  $domain=$q[$i][0];
	  $ttl=$q[$i][3];
	  $ttl='' unless ($ttl > 0);
	  printf ZONEFILE $ZFORMAT, $val,$ttl,$class,'MX',
	                            "$q[$i][1] $q[$i][2]";
	}
	print ZONEFILE ";\n";
      }
      undef @q; # entries without mx-templates
      db_query("SELECT h.domain,m.pri,m.mx,h.ttl " .
	       "FROM hosts h,zones z,mx_entries m " .
	       "WHERE h.zone=z.id AND m.ref=h.id AND m.type=2 " .
	       " AND h.type=3 AND h.mx=-1 AND z.id=$zoneid " .
	       "ORDER BY h.domain,m.pri,m.mx;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n;\n; MX only domains\n;\n";
	$domain='';
	for $i (0 .. $#q) {
	  print ZONEFILE ";\n" if ($domain ne '' && $domain ne $q[$i][0]);
	  $val=($domain ne $q[$i][0] ? $q[$i][0] : '');
	  $domain=$q[$i][0];
	  $ttl=$q[$i][3];
	  $ttl='' unless ($ttl > 0);
	  printf ZONEFILE $ZFORMAT, $val,$ttl,$class,'MX',
	                            "$q[$i][1] $q[$i][2]";
	}
	print ZONEFILE ";\n";
      }



      ## wks hash
      undef %wkshash;
      undef @q;
      # wks templates
      db_query("SELECT h.domain,w.proto,w.services FROM hosts h,zones z, " .
	             "wks_templates r, wks_entries w " .
	       "WHERE h.zone=z.id AND h.wks=r.id AND w.ref=r.id " .
	       "AND w.type=2 AND z.id=$zoneid AND h.type=1 " .
	       "ORDER BY h.domain, w.proto;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	$wks_count=@q;
	#print "found $wks_count wks entries!\n";
	for $i (0 .. $#q) {
	  $rec=$wkshash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[]; 
	    $wkshash{$q[$i][0]}=$rec;
	  }
	  $proto=$q[$i][1];
	  $proto=~s/\s+$//g;
	  push @{$wkshash{$q[$i][0]}}, "$proto $q[$i][2]";
	}
      }
      undef %wkshash2;
      undef @q;
      # wks entries (host specific)
      db_query("SELECT h.domain,w.proto,w.services " .
	       "FROM hosts h,zones z,wks_entries w " .
	       "WHERE z.id=$zoneid AND h.zone=z.id AND h.type=1 " .
	       " AND w.type=1 AND w.ref=h.id " .
	       "ORDER BY h.domain,w.proto;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	for $i (0 .. $#q) {
	  $rec=$wkshash2{$q[$i][0]};
	  if (!$rec) {
	    $rec=[]; 
	    $wkshash2{$q[$i][0]}=$rec;
	  }
	  $proto=$q[$i][1];
	  $proto=~s/\s+$//g;
	  push @{$wkshash2{$q[$i][0]}}, "$proto $q[$i][2]";
	}
      }



      ## mx hash (mx templates)
      undef %mxhash;
      undef @q;
      db_query("SELECT r.id,m.pri,m.mx " .
	       "FROM zones z,mx_templates r, mx_entries m " .
	       "WHERE z.id=$zoneid AND r.zone=z.id " .
	       "AND m.ref=r.id AND m.type=3 " .
	       "ORDER BY r.id,m.pri,m.mx;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	$mx_count=@q;
	#print "found $mx_count mx entries!\n";
	for $i (0 .. $#q) {
	  $rec=$mxhash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[];
	    $mxhash{$q[$i][0]}=$rec;
	  }
	  push @{$mxhash{$q[$i][0]}}, "$q[$i][1] $q[$i][2]";
	}
	#print "mxhash $mx_count : " . (keys %mxhash) . "\n";
	#foreach $foo (keys %mxhash) {  print "mx hash: $foo\n"; }
      }
      undef %mxhash2;
      undef @q;
      # mx entries (host specific)
      db_query("SELECT h.domain,m.pri,m.mx " .
	       "FROM hosts h,zones z,mx_entries m " .
	       "WHERE z.id=$zoneid AND h.zone=z.id AND h.type=1 " .
	       " AND m.type=2 AND m.ref=h.id " .
	       "ORDER BY h.domain,m.pri,m.mx;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	for $i (0 .. $#q) {
	  $rec=$mxhash2{$q[$i][0]};
	  if (!$rec) {
	    $rec=[]; 
	    $mxhash2{$q[$i][0]}=$rec;
	  }
	  push @{$mxhash2{$q[$i][0]}}, "$q[$i][1] $q[$i][2]";
	}
      }


      ## txt hash
      undef %txthash;
      undef @q;
      db_query("SELECT h.domain,t.txt FROM hosts h,zones z,txt_entries t " .
	       "WHERE h.zone=z.id AND t.type=2 AND t.ref=h.id " .
	       "AND h.type=1 AND z.id=$zoneid " .
	       "ORDER BY h.domain;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	for $i (0 .. $#q) {
	  $rec=$txthash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[];
	    $txthash{$q[$i][0]}=$rec;
	  }
	  $val=$q[$i][1];
	  $val =~ s/\"//g;
	  push @{$txthash{$q[$i][0]}}, $val;
	}
      }


      # normal host entries
      undef @q;
      undef %dnames;
      db_query("SELECT h.domain,a.ip,h.hinfo_hw,h.hinfo_sw,h.ttl,h.huser, " .
	       " h.dept,h.location,h.info,h.mx,h.expiration " .
	       "FROM hosts h, a_entries a, zones z " .
	       "WHERE h.zone=z.id AND a.host=h.id " .
	       "AND z.id=$zoneid AND h.type=1 " .
	       "AND a.forward=true AND h.domain <> '\@' " .
	       "ORDER BY a.ip,h.domain;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n;\n; A records\n;\n";
	for $i (0 .. $#q) {
	  #$domain=$q[$i][0];
	  $domain=remove_origin($q[$i][0],$origin);
	  if ($domain =~ /\.$/) {
	    error("Out-of-zone host skipped: $q[$i][0]");
	    next;
	  }
	  if ($domain =~ /\.($delegation_mask)$/) {
	    error("Host in delegated zone skipped: $q[$i][0]");
	    next;
	  }
	  if (($q[$i][10] > 0) && ($q[$i][10] < $time_now_ticks)) {
	    error("Skipping expired host: $q[$i][0]");
	    next;
	  }
	  $ip=$q[$i][1];
	  $ip =~ s/\/\d\d$//g;
	  $hinfo_hw=$q[$i][2];
	  $hinfo_sw=$q[$i][3];
	  $ttl=$q[$i][4];
	  $ttl='' unless ($ttl > 0);
	  $txt=$txthash{$domain};
	  $wks=$wkshash{$domain};
	  $wks=$wkshash2{$domain} if ($wkshash2{$domain});
	  $mx=$mxhash{$q[$i][9]};
	  $mx=$mxhash2{$domain} if ($mxhash2{$domain});
	  $info=$q[$i][5];
	  if ($q[$i][6]) { $info.=", " if ($info); $info.=$q[$i][6]; }
	  if ($q[$i][7]) { $info.=" " if ($info); $info.=$q[$i][7]; }
	  if ($q[$i][8]) { $info.=", " if ($info); $info.=$q[$i][8]; }
	  if ($dnames{$domain}) {
	    #error("duplicate A record $ip for $domain ($dnames{$domain}).");
	    printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$ip;
	    print ZONEFILE ";\n";
	    next;
	  }
	  $dnames{$domain}=$ip;
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$ip;
	  printf ZONEFILE $ZFORMAT, '',$ttl,$class,'HINFO',
	    "$hinfo_hw $hinfo_sw"  if ($hinfo_hw ne '' && $hinfo_sw ne '');
	  if ($wks) {
	    for $k (0 .. $#{$wks}) {
	      printf ZONEFILE $ZFORMAT, '',$ttl,$class,'WKS',"$ip $$wks[$k]";
	    }
	  }
	  if ($mx) {
	    for $k (0 .. $#{$mx}) {
	      $val=$$mx[$k];
              $val =~ s/\$DOMAIN/$domain/g;
	      printf ZONEFILE $ZFORMAT, '',$ttl,$class,'MX',$val;
	    }
	  }
	  for $k (0 .. $#{$txt}) {
	    $val=$$txt[$k];
	    $val =~ s/\"//g;
	    printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',"\"$val\"";
	  }
	  $info =~ s/\"//g;
	  printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',"\"$info\""
	    unless ($info eq '');
	  print ZONEFILE ";\n";
	}
      }


      # aliases (A records)
      undef @q;
      db_query("SELECT a.domain,b.domain,ae.ip,a.ttl,a.expiration " .
	       "FROM hosts a, hosts b,zones z, arec_entries r,a_entries ae " .
	       "WHERE z.id=$zoneid AND a.type=7 AND a.zone=z.id " .
	       " AND r.host=a.id AND b.id=r.arec AND ae.host=b.id " .
	       " AND ae.forward=true " .
	       "ORDER BY a.domain;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n;\n; In-zone aliases (A records)\n;\n";
	for $i (0 .. $#q) {
	  #$domain=$q[$i][0];
	  $domain=remove_origin($q[$i][0],$origin);
	  if ($domain =~ /\.$/) {
	    error("Out-of-zone alias (A rec) skipped: $q[$i][0]");
	    next;
	  }
	  if ($domain =~ /\.($delegation_mask)$/) {
	    error("Alias (A rec) in delegated zone skipped: $q[$i][0]");
	    next;
	  }
	  if (($q[$i][4] > 0) && ($q[$i][4] < $time_now_ticks)) {
	    error("Skipping expired A rec alias: $q[$i][0]");
	    next;
	  }
	  $alias=$q[$i][2];
	  $ttl=$q[$i][3];
	  $ttl='' unless ($ttl > 0);
	  $alias =~ s/\/\d{1,2}\s*$//g;
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'A',$alias;
	  printf ZONEFILE $ZFORMAT, '',$ttl,$class,'TXT',
	                   "\"IP alias for $q[$i][1]\"";
	  print ZONEFILE ";\n";
	}
      }

      # aliases (CNAME records)
      undef @q;
      db_query("SELECT a.domain,b.domain,a.ttl,a.expiration " .
	       "FROM hosts a, hosts b,zones z " .
	       "WHERE a.zone=z.id AND z.id=$zoneid " .
	       "AND a.type=4 AND a.alias=b.id " .
	       "ORDER BY a.domain;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n;\n; In-zone aliases (CNAME records)\n;\n";
	for $i (0 .. $#q) {
	  #$domain=$q[$i][0];
	  $domain=remove_origin($q[$i][0],$origin);
	  if ($domain =~ /\.$/) {
	    error("Out-of-zone alias (CNAME) skipped: $q[$i][0]");
	    next;
	  }
	  if ($domain =~ /\.($delegation_mask)$/) {
	    error("Alias (CNAME) in delegated zone skipped: $q[$i][0]");
	    next;
	  }
	  if (($q[$i][3] > 0) && ($q[$i][3] < $time_now_ticks)) {
	    error("Skipping expired CNAME alias: $q[$i][0]");
	    next;
	  }
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl > 0);
	  $alias=$q[$i][1];
	  $alias="$alias.$origin" unless ($alias =~ /\.$/);
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'CNAME',$alias;
	}
      }
      # aliases outside zone
      undef @q;
      db_query("SELECT h.domain,h.cname_txt,h.ttl,h.expiration " .
               "FROM hosts h,zones z " .
	       "WHERE h.zone=z.id AND z.id=$zoneid " .
	       "AND h.type=4 AND h.alias=-1 " .
	       "ORDER BY h.domain;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n;\n; Outside-zone aliases (CNAME records)\n;\n";
	for $i (0 .. $#q) {
	  #$domain=$q[$i][0];
	  $domain=remove_origin($q[$i][0],$origin);
	  if ($domain =~ /\.$/) {
	    error("Out-of-zone alias (CNAME) skipped: $q[$i][0]");
	    next;
	  }
	  if ($domain =~ /\.($delegation_mask)$/) {
	    error("Alias (CNAME) in delegated zone skipped: $q[$i][0]");
	    next;
	  }
	  if (($q[$i][3] > 0) && ($q[$i][3] < $time_now_ticks)) {
	    error("Skipping expired (out of zone) CNAME alias: $q[$i][0]");
	    next;
	  }
	  $alias=$q[$i][1];
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl > 0);
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'CNAME',$alias;
	}
      }


      # SRV records
      undef @q;
      db_query("SELECT a.domain,a.ttl,a.expiration," .
	       " b.pri,b.weight,b.port,b.target " .
	       "FROM hosts a, srv_entries b, zones z " .
	       "WHERE a.zone=z.id AND z.id=$zoneid " .
	       "AND a.type=8 AND a.id=b.ref " .
	       "ORDER BY a.domain,b.port,b.pri,b.weight,b.target;",\@q);
      error(db_errormsg()) if (db_errormsg());
      if (@q > 0) {
	print ZONEFILE ";\n;\n; SRV records\n;\n";
	for $i (0 .. $#q) {
	  $domain=remove_origin($q[$i][0],$origin);
	  if ($domain =~ /\.$/) {
	    error("Out-of-zone SRV record skipped: $q[$i][0]");
	    next;
	  }
	  if ($domain =~ /\.($delegation_mask)$/) {
	    error("SRV in delegated zone skipped: $q[$i][0]");
	    next;
	  }
	  if (($q[$i][2] > 0) && ($q[$i][2] < $time_now_ticks)) {
	    error("Skipping expired SRV record: $q[$i][0]");
	    next;
	  }
	  $ttl=$q[$i][2];
	  $ttl='' unless ($ttl > 0);
	  $pri=($q[$i][3] > 0 ? $q[$i][3] : 0);
	  $weight=($q[$i][4] > 0 ? $q[$i][4] : 0);
	  $port=($q[$i][5] > 0 ? $q[$i][5] : 0);
	  $target=$q[$i][6];
	  $target.=".$origin" unless ($target =~ /\.$/);
	  printf ZONEFILE $ZFORMAT, $domain,$ttl,$class,'SRV',
	         "$pri $weight $port $target";
	}
      }

    }

    print ZONEFILE ";\n;\n; eof\n";
    close(ZONEFILE);
  }

  print BINDFILE "\n\n// eof\n";
  close(BINDFILE);
}


######################################################################
# DHCP

sub make_dhcp() {
  print "DHCP configuration\n";
  $time_now = localtime;

  # dhcpd.conf
  print "Generating dhcpd.conf...\n";

  open(DHCPFILE,">dhcpd.conf") || fatal("Cannot create dhcpd.conf!");
  print DHCPFILE "# dhcpd.conf -- automagically generated using $0 $VER\n";
  print DHCPFILE "#               created by $user at $time_now\n#\n";

  # ether hash
  undef @q;
  db_query("SELECT h.ether,a.ip FROM hosts h,zones z,a_entries a " .
	   "WHERE z.server=$serverid AND h.zone=z.id AND a.host=h.id " .
	   " AND h.ether NOTNULL;",\@q);
  error(db_errormsg()) if (db_errormsg());
  for $i (0..$#q) {
    unless ($q[$i][0] =~ /^[0-9A-F]{12}$/) {
      error("Invalid ethernet address ($q[$i][0]) skipped");
      next;
    }
    $etherhash{$q[$i][0]}=[] unless ($etherhash{$q[$i][0]});
    push @{$etherhash{$q[$i][0]}}, $q[$i][1];
  }
  # add ehter_aliases to ether hash too
  undef @q;
  db_query("SELECT b.ether,c.ip FROM hosts a, hosts b, zones z, a_entries c ".
	   "WHERE z.server=$serverid AND a.zone=z.id AND a.ether_alias=b.id ".
	   " AND c.host=a.id;",\@q);
  error(db_errormsg()) if (db_errormsg());
  for $i (0..$#q) {
    unless ($q[$i][0] =~ /^[0-9A-F]{12}$/) {
      error("Invalid ethernet address ($q[$i][0]) skipped (ether_alias)");
      next;
    }
    $etherhash{$q[$i][0]}=[] unless ($etherhash{$q[$i][0]});
    push @{$etherhash{$q[$i][0]}}, $q[$i][1];
  }


  # host dhcp hash
  undef @q;
  db_query("SELECT h.id,d.dhcp FROM hosts h,zones z,dhcp_entries d " .
	   "WHERE z.server=$serverid AND h.zone=z.id AND d.type=3 " .
	   " AND d.ref=h.id;",\@q);
  for $i (0..$#q) {
    $dhcphosth{$q[$i][0]}=[] unless ($dhcphosth{$q[$i][0]});
    push @{$dhcphosth{$q[$i][0]}}, $q[$i][1];
  }


  # global entries

  print DHCPFILE "\n# global options\n\n";
  undef @q;
  db_query("SELECT d.dhcp FROM dhcp_entries d " .
	   "WHERE d.type=1 AND d.ref=$serverid;",\@q);
  for $i (0..$#q) {
    print DHCPFILE "$q[$i][0];\n";
  }
  print DHCPFILE "\n\n";


  # dynamic hosts
  unless ($dhcp2_mode) {
    undef @dclasses;
    db_query("SELECT id,name FROM groups WHERE server=$serverid AND type=3 " .
	     "ORDER BY name",\@dclasses);
    if (@dclasses > 0) {
      print DHCPFILE "\n# dynamic classes\n\n";
      for $i (0..$#dclasses) {
	print DHCPFILE "class \"$dclasses[$i][1]\" {\n";
	print DHCPFILE "\tmatch pick-first-value " .
	               "(option dhcp-client-identifier, hardware);\n";
	undef @q;
	db_query("SELECT dhcp FROM dhcp_entries " .
		 "WHERE type=5 and ref=$dclasses[$i][0] ORDER BY dhcp",\@q);
	for $j (0..$#q) {	print DHCPFILE "\t$q[$j][0];\n"; }
	print DHCPFILE "}\n";

	# subclasses
	undef @q;
	db_query("SELECT h.ether,h.domain FROM hosts h, zones z " .
	         "WHERE z.server=$serverid AND h.zone=z.id " .
	         " AND h.grp=$dclasses[$i][0] AND h.ether NOTNULL " .
	         "ORDER BY h.ether",\@q);
	for $j (0..$#q) {
	  unless ($q[$j][0] =~ /^[0-9A-F]{12}$/) {
	    #error("invalid ether for subclass: $q[$j][0]");
	    next;
	  }
	  print DHCPFILE "subclass \"$dclasses[$i][1]\" 1:" .
	                 dhcpether($q[$j][0]) . ";  # $q[$j][1]\n";
	}
      }
      print DHCPFILE "\n";
    }
  }


  # check for dynamic IP pools
  undef @dpools;
  db_query("SELECT id,name FROM groups WHERE server=$serverid AND type=2 ".
	   "ORDER BY name",\@dpools);
  if (@dpools > 0) {
    $dpools_count=@dpools;
    print STDERR "Found $dpools_count dynamic IP pools\n" if ($verbose);
    undef @dips;
    db_query("SELECT g.id,a.ip,h.domain ".
	     "FROM hosts h, a_entries a, groups g ".
	     "WHERE a.host=h.id AND g.id=h.grp AND g.type=2 ".
	     " AND g.server=$serverid ORDER BY a.ip,g.id",\@dips);
    $dpool_ip_count=@dips;
    print STDERR "Found $dpool_ip_count dynamic pool IPs\n" if ($verbose);


    undef %dpools_dhcp;
    for $i (0..$#dpools) {
      undef @q;
      db_query("SELECT dhcp FROM dhcp_entries " .
	       "WHERE type=5 AND ref=$dpools[$i][0] ORDER BY dhcp",\@q);
      $dpools_dhcp{$i}=[];
      for $j (0..$#q) { push @{$dpools_dhcp{$i}}, $q[$j][0]; }
    }
  }

  # net/subnet map

  $net_map_mode=0;  # 0=use VLANs, 1=use networks

  print DHCPFILE "\n# network map\n\n";
  undef @subnets;
  undef @nets;
  db_query("SELECT net,name,id,vlan " . 
	   "FROM nets WHERE server=$serverid AND no_dhcp=false " .
	   "AND subnet=false ORDER BY net;",\@nets);
  if (@nets < 1) {
    fatal("No nets, that use DHCP, defined for this server!");
  }
  for $i (0 .. $#nets) {
    $net=$nets[$i][0];
    $netname=$nets[$i][1];
    $netname =~ s/\s+//g;
    if ($net_map_mode == 1) {
      print DHCPFILE "shared-network \"$netname\" {\n";
      undef @net_dhcp;
      db_query("SELECT d.dhcp FROM dhcp_entries d " .
	       "WHERE d.type=4 AND d.ref=$nets[$i][2];",\@net_dhcp);
      for $j (0..$#net_dhcp) { print DHCPFILE "\t$net_dhcp[$i][0];\n"; }
      print DHCPFILE "\n";
    }

    undef @q;
    db_query("SELECT net,id,name,vlan FROM nets " .
	     "WHERE server=$serverid AND no_dhcp=false AND subnet=true " .
	     "AND net << '$net' ORDER BY net;",\@q);
    if (@q < 1 ) {
      error("No subnets that use DHCP found") if ($net_map_mode==1);
      push @q, [$net,$nets[$i][2],$nets[$i][1],$nets[$i][3]];
    }

    if ($net_map_mode == 1) {
      print_subnets();
      print DHCPFILE "}\n\n";
    } else {
      push (@subnets,@q);
    }
  }

  if ($net_map_mode == 0) {
    # print network map using VLANs...
    undef %vlanhash;
    for $i (0..$#subnets) {
      $vlanhash{$subnets[$i][3]}++;
    }
    get_vlan_list($serverid,\%vlan_list_hash,\@vlan_list_lst);
    foreach $vlan (sort keys %vlanhash) {
      $netname=$vlan_list_hash{$vlan};
      $netname =~ s/\s//g;
      $netname = 'CHAOS' if ($vlan < 1 || $netname eq '');
      print DHCPFILE "shared-network \"$netname\" {\n";
      undef @q;
      for $i (0..$#subnets) {
	push ( @q, $subnets[$i])  if ($subnets[$i][3] eq $vlan);
      }
      print_subnets();
      print DHCPFILE "}\n\n";
    }
  }


  # groups

  print DHCPFILE "# groups\n\n";

  undef @groups;
  db_query("SELECT id,name FROM groups WHERE server=$serverid AND " .
	   "(type=1 OR type=3) " .
	   "ORDER BY name;",\@groups);
  if (@groups < 1) {
    error("no groups found for this server");
  }
  else {
    undef @ghosts;
    db_query("SELECT h.grp,h.ether,a.ip,h.domain,z.name,h.id,h.expiration " .
	     "FROM hosts h, zones z, a_entries a " .
	     "WHERE h.zone=z.id AND a.host=h.id AND h.type=1 " .
	     "AND h.ether NOTNULL AND z.server=$serverid " .
	     "AND h.grp>-1 " .
	     "ORDER BY a.ip;",\@ghosts);
    if (@ghosts > 0) {
      for $i (0.. $#groups) {
	$gid=$groups[$i][0];
	$group=$groups[$i][1];
	# $dhcp=db_decode_list_str($groups[$i][2]);
	print DHCPFILE "group {  # $group\n";
	undef @qqq;
	db_query("SELECT d.dhcp FROM dhcp_entries d " .
		 "WHERE d.type=5 AND d.ref=$gid;",\@qqq);
	for $k (0..$#qqq) {
	  $qqq[$k][0] =~ s/\\"/"/g;
	  print DHCPFILE "\t$qqq[$k][0];\n";
	}
	print DHCPFILE "\t\n";

	for $j (0 .. $#nets) {
	  $net=new Net::Netmask($nets[$j][0]);
	  print DHCPFILE "\t# net: " .$net->desc() . "\n";
	  for $k (0 .. $#ghosts) {
	    if (($ghosts[$k][6] > 0) && ($ghosts[$k][6] < $time_now_ticks)) {
	      # error("expired host in DHCP: $ghosts[$k][3]");
	      next;
	    }
	    $iplst=$etherhash{$ghosts[$k][1]};
	    @{$iplst} = sort(@{$iplst}) if (@{$iplst}>1);
	    $ip='';
	    for $l (0..$#{$iplst}) {
	      if ($net->match($$iplst[$l])) {
		$ip.=", " if ($ip ne '');
		$ip.=$$iplst[$l];
	      }
	    }
	    #print "IP '$ip'\n" if ($ip =~ /,/);
	    if ($ghosts[$k][0]==$gid && ($ip ne '')) {
	      $host=$ghosts[$k][3];
	      $host.=".$ghosts[$k][4]" unless ($host =~ /\.$/);
	      $host =~ s/\.$//;
	      $ether=dhcpether($ghosts[$k][1]);
	      #$dhcp=db_decode_list_str($ghosts[$k][5]);
	      $dhcpid=$ghosts[$k][5];
	      if ($ethers{$ether}>0) {
		error("dublicate interface $ip for $ether ($host)");
		next;
	      }
	      $ethers{$ether}++;
	      print DHCPFILE "\thost $host {\n";
	      print DHCPFILE "\t\tfixed-address $ip;\n";
	      print DHCPFILE "\t\thardware ethernet $ether;\n";
	      if ($dhcp_auto_domainnames) {
		($adomain=$host) =~ s/^[^\.]+\.//;
		print DHCPFILE "\t\toption domain-name \"$adomain\";\n"
		  if ($adomain);
	      }

	      $dhcplst=$dhcphosth{$dhcpid};
	      for $l (0..$#{$dhcplst}) {
		print DHCPFILE "\t\t$$dhcplst[$l];\n";
	      }
	      print DHCPFILE "\t}\n";
	    }
	  }
	}
	print DHCPFILE "}\n\n";
      }
    } else {
      print "no hosts found for any groups!";
    }
  }

  # not grouped hosts...
  print DHCPFILE "\n# hosts not in any group\n\n";
  undef @ghosts;
  db_query("SELECT h.grp,h.ether,a.ip,h.domain,z.name,h.id,h.expiration " .
	   "FROM hosts h, zones z, a_entries a " .
	   "WHERE h.zone=z.id AND a.host=h.id AND ( h.type=1 OR h.type=9 ) " .
	   "AND h.ether NOTNULL AND z.server=$serverid " .
	   "AND h.grp<0 " .
	   "ORDER BY a.ip;",\@ghosts);
  if (@ghosts > 0 ) {
    for $j (0 .. $#nets) {
      $net=new Net::Netmask($nets[$j][0]);
      print DHCPFILE "# net: " .$net->desc() . "\n";
      for $k (0 .. $#ghosts) {
	if (($ghosts[$k][6] > 0) && ($ghosts[$k][6] < $time_now_ticks)) {
	  # error("expired host in DHCP: $ghosts[$k][3]");
	  next;
	}
	$iplst=$etherhash{$ghosts[$k][1]};
	@{$iplst} = sort(@{$iplst}) if (@{$iplst}>1);
	$ip='';
	for $l (0..$#{$iplst}) {
	  if ($net->match($$iplst[$l])) {
	    $ip.=", " if ($ip ne '');
	    $ip.=$$iplst[$l];
	  }
	}
	#print "IP '$ip'\n" if ($ip =~ /,/);
	if ($ip ne '') {
	  $host=$ghosts[$k][3];
	  $host.=".$ghosts[$k][4]" unless ($host =~ /\.$/);
	  $host =~ s/\.$//;
	  $ether=dhcpether($ghosts[$k][1]);
	  #$dhcp=db_decode_list_str($ghosts[$k][5]);
	  $dhcpid=$ghosts[$k][5];
	  if ($ethers{$ether}>0) {
	    #error("duplicate interface $ip for $ether ($host)");
	    next;
	  }
	  $ethers{$ether}++;
	  print DHCPFILE "host $host {\n";
	  print DHCPFILE "\tfixed-address $ip;\n";
	  print DHCPFILE "\thardware ethernet $ether;\n";
	  if ($dhcp_auto_domainnames) {
	    ($adomain=$host) =~ s/^[^\.]+\.//;
	    print DHCPFILE "\toption domain-name \"$adomain\";\n"
	      if ($adomain);
	  }

	  $dhcplst=$dhcphosth{$dhcpid};
	  for $l (0..$#{$dhcplst}) {
	    print DHCPFILE "\t$$dhcplst[$l];\n";
	  }
	  print DHCPFILE "}\n";
	}
      }
    }
  }

  undef @ghosts;
  undef %ethers;


  print DHCPFILE "\n# eof\n";
  close(DHCPFILE);
}




sub print_subnets() {
  my(@qq,@qqq,$j,$k,$l,$router,$ssnet,$snet,$nmask,$dhcpid,$pri);
  my(@ranges,$lst,$s,$b,$e,$last,$first_pool);

  for $k (0..$#dpools) { $ranges[$k]=[]; }

  db_query("SELECT ip,router FROM hosts,zones,a_entries " .
	       "WHERE hosts.zone=zones.id AND a_entries.host=hosts.id " .
	       "AND zones.server=$serverid AND router>0 " .
	       "AND ip << '$net' " .
	       "ORDER BY ip,router;",\@qq);
  error("No router interfaces found for net $net!") if (@qq < 1);

  for $j (0 .. $#q) {
    $ssnet = new Net::Netmask($q[$j][0]);
    $snet = $ssnet->base();
    $nmask = $ssnet->mask();
    $dhcpid = $q[$j][1];
    print DHCPFILE "\t# $q[$j][2]\n";
    print DHCPFILE "\tsubnet $snet netmask $nmask {\n";

    $pri=999999; # should be enough 'cos priority range for a router 0-999
    $router='';
    for $k (0 .. $#qq) {
      if ($ssnet->match($qq[$k][0]) && $pri > $qq[$k][1]) {
	$pri=$qq[$k][1];
	$router=$qq[$k][0];
      }
    }
    unless ($router eq '') {
      $router =~ s/\/\d{1,2}\s*$//g;
      print DHCPFILE "\t\toption routers $router;\n";
    } else {
      print "no router interface found for subnet: $snet $nmask\n";
    }

    undef @qqq;
    db_query("SELECT d.dhcp FROM dhcp_entries d " .
	     "WHERE d.type=4 AND d.ref=$dhcpid;",\@qqq);
    for $k (0..$#qqq) {
      print DHCPFILE "\t\t$qqq[$k][0];\n";
    }

    print DHCPFILE "\t}\n";

    # look for dynamic IP pools within this subnet
    if ($dpools_count > 0) {
      for $k (0..$#dpools) {
	$lst=$ranges[$k];
	$s=0;
	for $l (0..$#dips) {
	  if (($dips[$l][0]==$dpools[$k][0]) && $ssnet->match($dips[$l][1])) {
	    #print "foo: $snet $dips[$l][1]\n";
	    if ($s==0) { $s=1; $b=$dips[$l][1]; }
	    $last=$l;
	  } else {
	    if ($s==1) { 
	      $e=$dips[$last][1]; push @{$lst}, "range $b $e;";
	      print STDERR "dynamic range $b - $e ($dpools[$k][1])\n"
		if ($verbose);
	    }
	    $s=0;
	  }
	}
	if ($s==1) { 
	  $e=$dips[$last][1]; push @{$lst}, "range $b $e;"; 
	  print STDERR "dynamic range $b - $e ($dpools[$k][1])\n" 
	    if ($verbose);
	}
      }
    }
  }

  unless ($dhcp2_mode) {
    $first_pool=1;
    for $j (0..$#dpools) {
      $lst=$ranges[$j];
      next unless (@{$lst} > 0);
      print DHCPFILE "\n\t# dynamic IP pools\n\n" if ($first_pool);
      $first_pool=0;
      print DHCPFILE "\tpool {  # $dpools[$j][1]\n";
      for $k (0..$#{$dpools_dhcp{$j}}) {
	print DHCPFILE "\t\t${$dpools_dhcp{$j}}[$k];\n";
      }
      for $k (0..$#{$lst}) {
	print DHCPFILE "\t\t$$lst[$k]\n";
      }
      print DHCPFILE "\t}\n\n";
    }
  }

}

######################################################################
# printcap

sub make_printcap() {
  print "PRINTER configuration\n";
  $time_now = localtime;

  # printcap
  print "Generating printcap...\n";


  open(PCAPFILE,">printcap") || fatal("Cannot create printcap!");
  print PCAPFILE "# printcap -- automagically generated using $0 $VER\n";
  print PCAPFILE "#             created by $user at $time_now\n#\n";


  # FIXME .................................!!!!!!!!!!

  print PCAPFILE "# eof\n";
  close(PCAPFILE);
}


############################################################################

sub dhcpether($) {
  my ($e) = @_;

  $e="\L$e";
  if ($e =~ /(..)(..)(..)(..)(..)(..)/) {
    return "$1:$2:$3:$4:$5:$6";
  }

  return "00:00:00:00:00:00";
}

sub error($) {
  my ($msg) = @_;

  print STDERR "$0: $msg\n";
}

sub fatal($) {
  my ($msg) = @_;
  error($msg);
  exit 1;
}


# eof
