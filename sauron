#!/usr/bin/perl
#
# sauron - generates BIND/DHCP/printer configuration files from database
#
# Copyright (c) Timo Kokkonen <tjko@iki.fi>  2000.
# $Id$
#
require 5;
use Net::Netmask;

($PG_DIR,$PG_NAME) = ($0 =~ /^(.*\/)(.*)$/);
$0 = $PG_NAME;

do "$PG_DIR/config" || fatal("cannot load config");
do "$PG_DIR/util.pl";
do "$PG_DIR/db.pl";
do "$PG_DIR/back_end.pl";

$bind_conf=0;
$dhcp_conf=0;
$printer_conf=0;


#@a = (1,2,3);
#@b = (5,6,7);
#@c = (@a , @b);
#print @a . " " . join(",",@a) . "\n";
#print @b . " " . join(",",@b) . "\n";
#print @c . " " . join(",",@c) . "\n";



##############################

for ($i=0; $i < @ARGV; $i++) {
  $argument=$ARGV[$i];
  last unless ($argument =~ /^-\S+$/);

  for ($j=1;$j < length($argument); $j++) {
    $arg=substr($argument,$j,1);

    if ($arg eq 'a') {
      $bind_conf=1; 
      $dhcp_conf=1; 
      $printer_conf=1;
    } 
    elsif ($arg eq 'b') {
      $bind_conf=1;
    } 
    elsif ($arg eq 'd') {
      $dhcp_conf=1;
    } 
    elsif ($arg eq 'p') {
      $printer_conf=1;
    } 
    else {
      print STDERR "$0: unknown command line option '$arg' (ignored)\n";
    }
  }

}

$argc=@ARGV - $i;

if ($argc < 1 || $argc > 2) {
    print "syntax: $0 [-abdp] <servername> [<target directory>]\n";
    exit(1);
}


$servername = $ARGV[$i];
if ($argc > 1) {
	$targetdir = $ARGV[$i+1];
	$targetdir .= "/" unless ($targetdir =~ /\/$/);
} else {
	$targetdir = "./";
}
$user = (getpwuid($<))[0];


fatal("target directory is a file! ($targetdir)") if (-f $targetdir);
fatal("target directory does not exists ($targetdir)") if (! -d $targetdir);
fatal("no permissions to target directory!") 
	unless (-r $targetdir && -x $targetdir && -w $targetdir);

print "server name: $servername\n";
print "target directory: $targetdir\n";

chdir($targetdir) || fatal("Cannot change to directory '$targetdir'!");

db_connect();

#########################################################################



$serverid = get_server_id($servername);
fatal("Cannot find server '$servername' from database.") if ($serverid < 0);
fatal("Cannot get server record!") if (get_server($serverid,\%server));


$zonelist = get_zone_list($serverid);
#$zonelist2 = get_zone_list(0);
#$zonelist = [@{$zonelist1},@{$zonelist2}];

$zones = @{$zonelist};
print "Server '$servername' has $zones zones.\n";

make_bind() if ($bind_conf);
make_dhcp() if ($dhcp_conf);
make_printcap() if ($printer_conf);

exit;
#######

sub make_bind() {
  print "BIND configuration\n";
  $time_now = gmtime;

  ##################################################
  # named.conf
  print "Generating named.conf...\n";
  
  open(BINDFILE,">named.conf") || fatal("Cannot create named.conf!");
  print BINDFILE "// named.conf -- automagically generated using $0 $VER\n";
  print BINDFILE "//               created by $user at $time_now\n//\n";

  #options section
  print BINDFILE "options {\n";
  print BINDFILE "\tdirectory \"$server{'directory'}\";\n"
    if ($server{'directory'} ne '');

  undef @q;
  db_query("SELECT ip FROM cidr_entries WHERE type=1 AND ref=$serverid;",\@q);
  if (@q > 0) {
    print BINDFILE "\tallow-transfer {\n";
    for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
    print BINDFILE "\t};\n";
  }

  print BINDFILE "};\n";


  #zones section
  print BINDFILE "\n\nzone \".\" in {\n";
  print BINDFILE "\ttype hint;\n";
  print BINDFILE "\tfile \"$server{'named_ca'}\";\n";
  print BINDFILE "};\n\n\n";

  for($loopcounter=0; $loopcounter < $zones; $loopcounter++) {
    $zonename=$$zonelist[$loopcounter][0];
    $zonename =~ s/\.$//g;
    $origin = $zonename . '.';
    $zoneid=$$zonelist[$loopcounter][1];
    #print "zone: $zonename id=$zoneid\n";
    fatal("Cannot get zone record: $zonename (id=$zoneid)!") 
      if (get_zone($zoneid,\%zone));

    if ($zone{'type'} eq 'M') { $type='master'; }
    elsif ($zone{'type'} eq 'S') { $type='slave'; }
    elsif ($zone{'type'} eq 'H') { $type='hint'; }
    elsif ($zone{'type'} eq 'F') { $type='forward'; }

    if ($type eq 'master') { $zfile=$server{'mzone_path'}; } 
    elsif ($type eq 'slave') { $zfile=$server{'szone_path'}; }
    else { $zfile=''; }
    $zfile.=$zonename . ".zone";

    print BINDFILE "zone \"$zonename\" $zone{'class'} {\n";
    print BINDFILE "\ttype $type;\n";
    print BINDFILE "\tcheck-names warn;\n" if ($zone{'chknames'} eq 'W');
    print BINDFILE "\tcheck-names ignore;\n" if ($zone{'chknames'} eq 'I');
    print BINDFILE "\tcheck-names fail;\n" if ($zone{'chknames'} eq 'F');
    print BINDFILE "\tfile \"$zfile\";\n"
      if ($type eq 'master' || $type eq 'slave');

    # allow_update
    undef @q;
    db_query("SELECT ip FROM cidr_entries WHERE type=2 AND ref=$zoneid;",\@q);
    if (@q > 0) {
      print BINDFILE "\tallow-update {\n";
      for $j (0..(@q-1)) { print BINDFILE "\t\t$q[$j][0];\n"; }
      print BINDFILE "\t};\n";
    }

    # masters
    if ($type eq 'slave') {
      undef @q;
      db_query("SELECT ip FROM cidr_entries WHERE type=3 AND ref=$zoneid;",
	       \@q);
      if (@q > 0) {
	print BINDFILE "\tmasters { ";
	for $j (0..(@q-1)) { 
	  $ip=$q[$j][0];
	  $ip =~ s/\/32$//g;
	  print BINDFILE "$ip; "; 
	}
	print BINDFILE " };\n";
      }
    }
    
    print BINDFILE "};\n\n\n";


    next unless ($type eq 'master');
    if ($zone{'dummy'} eq 't') {
      print "Skipping zone creation for dummy zone: $zonename\n";
      next;
    }
   
    ######################
    # .zone files
    print "Generating zone file: $zfile\n";
    open(ZONEFILE, ">$zfile") || fatal("Cannot create file: $zfile!");
    $time_now=gmtime;
    print ZONEFILE "; zone $zonename - automagically generated by $0 $VER\n";
    print ZONEFILE "; =====" . '=' x length($zonename) . "\n;\n";
    print ZONEFILE "; created by: $user  $time_now\n";
    print ZONEFILE ";\n;\n";

    $rev=$zone{'reverse'};
    $class=$zone{'class'};
    $class=~s/\s+$//g;
    $ttl=$zone{'ttl'};
    $ttl='' unless ($ttl > 0);
    $serial=new_serial($zone{'serial'});
    fatal("Cannot update zone $zonename serial!")
      if (update_zone({id=>$zoneid,serial=>$serial}));
    $hostname=$server{'hostname'};
    $hostmaster=$zone{'hostmaster'};
    $hostmaster=$server{'hostmaster'} if ($hostmaster eq '');
    fatal("no hostmaster defined either in server nor zone record for: " .
	  "$zonename") if ($hostmaster eq '');
    fatal("server hostname not defined!") if ($hostname eq '');

    print ZONEFILE "@\t$ttl\t$class\tSOA\t$hostname $hostmaster (\n";
    print ZONEFILE "\t\t\t\t\t$serial\t; serial number\n" .
                   "\t\t\t\t\t$zone{'refresh'}\t\t; refresh\n" .
		   "\t\t\t\t\t$zone{'retry'}\t\t; retry\n" .
                   "\t\t\t\t\t$zone{'expire'}\t\t; expire\n" .
		   "\t\t\t\t\t$zone{'minimum'}\t\t; minimum\n\t\t\t\t\t)\n";
    print ZONEFILE ";\n; zone nameservers\n;\n";
    undef @q;
    db_query("SELECT ns FROM ns_entries WHERE type=1 AND ref=$zoneid;",\@q);
    foreach $ns (@q) {
      print ZONEFILE "\t\t$class\tNS\t$$ns[0]\n";
    }
    if ($rev eq 'f') {
      print ZONEFILE ";\n; zone mail exchanges\n;\n";
      undef @q;
      db_query("SELECT mx FROM mx_entries WHERE type=1 AND ref=$zoneid;",\@q);
      foreach $mx (@q) {
	print ZONEFILE "\t\t$class\tMX\t$$mx[0]\n";
      }
      print ZONEFILE ";\n; contact info\n;\n";
      undef @q;
      db_query("SELECT txt FROM txt_entries WHERE type=1 AND ref=$zoneid;",
	       \@q);
      foreach $txt (@q) {
	print ZONEFILE "\t\t$class\tTXT\t\"$$txt[0]\"\n";
      }

      # zone A records
      undef @q;
      db_query("SELECT ip FROM hosts,rr_a,zones " .
	       "WHERE hosts.zone=zones.id AND rr_a.host=hosts.id AND " .
	       "zones.id=$zoneid AND domain='\@';",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n; zone A record(s)\n;\n";
	for $i (0 .. $#q) {
	  $net = new Net::Netmask($q[$i][0]);
	  print ZONEFILE "\t\t$class\tA\t" . $net->base() . "\n";
	}
      }

    }


    # delegated zones
    undef @q;
    db_query("SELECT a.domain,c.ns FROM hosts a,zones b,ns_entries c " .
	     "WHERE c.ref=a.id AND a.zone=b.id AND c.type=2 AND a.type=2 " .
	     "AND b.id=$zoneid " .
	     "ORDER BY a.domain;",\@q);
    if (@q > 0) {
      print ZONEFILE ";\n;\n; delegated zones\n;\n";
      $domain='';
      for $i (0 .. $#q) {
	print ZONEFILE ";\n" if (($domain ne '') && ($domain ne $q[$i][0]));
	print ZONEFILE "$q[$i][0]" if ($domain ne $q[$i][0]);
	$domain=$q[$i][0];
	$ns=$q[$i][1];
	print ZONEFILE "\t\t$class\tNS\t" . $ns . "\n";
      }
	print ZONEFILE ";\n";
    }


    
    if ($rev eq 't') {
      # reverse zone

      #print "reversenet " . $zone{'reversenet'} . "\n";
      $rorigin = cidr2arpa($zone{'reversenet'}) . ".";

      # build list of zones to use for building reverse map
      undef @q; 
      undef @r_ids;
      db_query("SELECT id FROM zones WHERE server=$serverid AND dummy='f' " .
	       "AND type='M' AND reverse='f' " .  #   "AND noreverse='f' " .
	       "ORDER BY id;",\@q);
      for $i (0 .. $#q) {
	push @r_ids, $q[$i][0];
      }

      foreach $rzoneid (@r_ids) {
	undef @q;
	db_query("SELECT name FROM zones WHERE id=$rzoneid;",\@q);
	if (@q < 1) {
	  warn("cannot find zone (id=$rzoneid)!");
	  next;
	}
	$rzone_name=$q[0][0];

	undef @q;
	db_query("SELECT ip,domain FROM hosts,zones,rr_a " .
		 "WHERE hosts.zone=zones.id AND rr_a.host=hosts.id " .
		 "AND zones.id=$rzoneid AND rr_a.reverse=true " .
		 "AND ip << '$zone{'reversenet'}' " .
		 "ORDER BY ip;",\@q);
	if (@q > 0) {
	  print ZONEFILE ";\n; reverse map from zone: $rzone_name\n;\n";
	  for $i (0 .. $#q) {
	    $rip=remove_origin(cidr2arpa($q[$i][0]).".",$rorigin);
	    $rdomain=$q[$i][1];
	    if ($rdomain eq '@') {
	      $rdomain = "$rzone_name.";
	    } else {
	      $rdomain .= ".$rzone_name." unless ($rdomain =~ /\.$/);
	    }
	    print ZONEFILE "$rip\t$ttl\t$class\tPTR\t$rdomain\n";
	  }
	}
      }

    } else {
      # normal zone

      # glue records needed for delgated zones
      undef @q;
      db_query("SELECT hosts.domain,rr_a.ip FROM hosts,zones,rr_a " .
	       "WHERE hosts.zone=zones.id AND hosts.id=rr_a.host " .
	       "AND zones.id=$zoneid AND hosts.type=6 " .
	       "ORDER BY hosts.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n; Glue A records\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $ip=$q[$i][1];
	  $ip =~ s/\/\d{1,2}$//g;
	  print ZONEFILE "$domain\t\t$class\tA\t$ip\n";
	}
      }


      # plain MX domains

      undef @q; # entries with mx-templates
      db_query("SELECT h.domain,m.pri,m.mx " .
	       "FROM hosts h,zones z,mx_entries m,mx_templates r " .
	       "WHERE h.zone=z.id AND h.mx=r.id AND m.ref=r.id AND m.type=3 " .
	       " AND h.type=3 AND h.mx > 0 AND z.id=$zoneid " .
	       "ORDER BY h.domain,m.pri;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; MX only domains (using MX-templates)\n;\n";
	$domain='';
	for $i (0 .. $#q) {
	  print ZONEFILE ";\n" if ($domain ne '' && $domain ne $q[$i][0]);
	  print ZONEFILE "$q[$i][0]" if ($domain ne $q[$i][0]);
	  $domain=$q[$i][0];
	  print ZONEFILE "\t\t$class\tMX\t$q[$i][1] $q[$i][2]\n";
	}
	print ZONEFILE ";\n";
      }
      undef @q; # entries without mx-templates
      db_query("SELECT h.domain,m.pri,m.mx " .
	       "FROM hosts h,zones z,mx_entries m " .
	       "WHERE h.zone=z.id AND m.ref=h.id AND m.type=2 " .
	       " AND h.type=3 AND h.mx=-1 AND z.id=$zoneid " .
	       "ORDER BY h.domain,m.pri;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; MX only domains\n;\n";
	$domain='';
	for $i (0 .. $#q) {
	  print ZONEFILE ";\n" if ($domain ne '' && $domain ne $q[$i][0]);
	  print ZONEFILE "$q[$i][0]" if ($domain ne $q[$i][0]);
	  $domain=$q[$i][0];
	  print ZONEFILE "\t\t$class\tMX\t$q[$i][1] $q[$i][2]\n";
	}
	print ZONEFILE ";\n";
      }




      ## wks hash
      undef %wkshash;
      undef @q;
      db_query("SELECT h.domain,w.proto,w.services FROM hosts h,zones z, " .
	             "wks_templates r, wks_entries w " .
	       "WHERE h.zone=z.id AND h.wks=r.id AND w.ref=r.id " .
	       "AND w.type=2 AND z.id=$zoneid AND h.type=1 " .
	       "ORDER BY h.domain, w.proto;",\@q);
      if (@q > 0) {
	$wks_count=@q;
	#print "found $wks_count wks entries!\n";
	for $i (0 .. $#q) {
	  $rec=$wkshash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[]; 
	    $wkshash{$q[$i][0]}=$rec;
	  }
	  $proto=$q[$i][1];
	  $proto=~s/\s+$//g;
	  push @{$wkshash{$q[$i][0]}}, "$proto $q[$i][2]";
	}
      }

      # ADD here code for wks records beloging to host directly!!!!!!!!!!!



      ## mx hash
      undef %mxhash;
      undef @q;
      db_query("SELECT h.domain,m.pri,m.mx FROM hosts h,zones z,mx_templates r, " .
	         "mx_entries m " .
	       "WHERE h.zone=z.id AND h.mx=r.id AND m.ref=r.id AND m.type=3 " .
	       "AND z.id=$zoneid AND h.type=1 " .
	       "ORDER BY h.domain,m.pri,m.mx;",\@q);
      if (@q > 0) {
	$mx_count=@q;
	#print "found $mx_count mx entries!\n";
	for $i (0 .. $#q) {
	  $rec=$mxhash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[];
	    $mxhash{$q[$i][0]}=$rec;
	  }
	  push @{$mxhash{$q[$i][0]}}, "$q[$i][1] $q[$i][2]";
	}
      }

      # ADD here code for mx records belonging to host directly!!!!!!!!!!!

      
      ## txt hash
      undef %txthash;
      undef @q;
      db_query("SELECT h.domain,t.txt FROM hosts h,zones z,txt_entries t " .
	       "WHERE h.zone=z.id AND t.type=2 AND t.ref=h.id " .
	       "AND h.type=1 AND z.id=$zoneid " .
	       "ORDER BY h.domain;",\@q);
      if (@q > 0) {
	for $i (0 .. $#q) {
	  $rec=$txthash{$q[$i][0]};
	  if (!$rec) {
	    $rec=[];
	    $txthash{$q[$i][0]}=$rec;
	  }
	  push @{$txthash{$q[$i][0]}}, "$q[$i][1]";
	}
      }


      # normal host entries
      undef @q;
      undef %dnames;
      db_query("SELECT hosts.domain,ip,hinfo_hw,hinfo_sw " .
	       "FROM hosts,rr_a " .
	       "WHERE hosts.zone=zones.id AND rr_a.host=hosts.id " .
	       "AND zones.id=$zoneid AND hosts.type=1 " .
	       "AND rr_a.forward=true AND hosts.domain <> '\@' " .
	       "ORDER BY rr_a.ip,hosts.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; A records\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $ip=$q[$i][1];
	  $ip =~ s/\/\d\d$//g;
	  $hinfo_hw=$q[$i][2];
	  $hinfo_sw=$q[$i][3];
	  $txt=$txthash{$domain};
	  $wks=$wkshash{$domain};
	  $mx=$mxhash{$domain};
	  if ($dnames{$domain}) {
	    #error("duplicate A record $ip for $domain ($dnames{$domain}).");
	    #next;
	  }
	  $dnames{$domain}=$ip;
	  #	print ZONEFILE "$domain\t\t$class\tA\t" . $ip . "\n";
	  printf ZONEFILE "%-22s\t\t%s  A\t%s\n",$domain,$class,$ip;
	  print ZONEFILE "\t\t$class  HINFO\t$hinfo_hw $hinfo_sw\n"
	    if ($hinfo_hw ne '' && $hinfo_sw ne '');
	  if ($wks) {
	    for $k (0 .. $#{$wks}) {
	      print ZONEFILE "\t\t$class  WKS\t$ip " . $$wks[$k] . "\n";
	    }
	  }
	  if ($mx) {
	    for $k (0 .. $#{$mx}) {
	      $$mx[$k] =~ s/\$DOMAIN/$domain/g;
	      print ZONEFILE "\t\t$class  MX\t" . $$mx[$k] . "\n";
	    }
	  }
	  for $k (0 .. $#{$txt}) {
	    print ZONEFILE "\t\t$class  TXT\t\"" . $$txt[$k] . "\"\n";
	  }
	  
	  print ZONEFILE ";\n";
	}
      }


      # aliases (A records)
      undef @q;
      db_query("SELECT a.domain,b.domain,rr_a.ip " .
	       "FROM hosts a, hosts b,zones,rr_a " .
	       "WHERE a.zone=zones.id AND rr_a.host=b.id " .
	       "AND zones.id=$zoneid AND rr_a.forward=true " .
	       "AND a.type=4 AND a.cname=false AND a.alias=b.id " .
	       "ORDER BY a.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; In-zone aliases (A records)\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $alias=$q[$i][2];
	  $alias =~ s/\/\d{1,2}\s*$//g;
	  printf ZONEFILE "%-22s\t\t%s  A\t%s\n",$domain,$class,$alias;
	  printf ZONEFILE "\t\t\tTXT\t\"alias for $q[$i][1]\"\n";
	}
      }

      # aliases (CNAME records)
      undef @q;
      db_query("SELECT a.domain,b.domain FROM hosts a, hosts b,zones " .
	       "WHERE a.zone=zones.id AND zones.id=$zoneid " .
	       "AND a.type=4 AND a.cname=true AND a.alias=b.id " .
	       "ORDER BY a.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; In-zone aliases (CNAME records)\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $alias=$q[$i][1];
	  $alias="$alias.$origin" unless ($alias =~ /\.$/);
	  printf ZONEFILE "%-22s\t\t%s  CNAME\t%s\n",$domain,$class,$alias;
	}
      }
      # aliases outside zone
      undef @q;
      db_query("SELECT domain,cname_txt FROM hosts,zones " .
	       "WHERE hosts.zone=zones.id AND zones.id=$zoneid " .
	       "AND hosts.type=4 AND hosts.cname=true AND hosts.alias=-1 " .
	       "ORDER BY hosts.domain;",\@q);
      if (@q > 0) {
	print ZONEFILE ";\n;\n; Outside-zone aliases (CNAME records)\n;\n";
	for $i (0 .. $#q) {
	  $domain=$q[$i][0];
	  $alias=$q[$i][1];
	  printf ZONEFILE "%-22s\t\t%s  CNAME\t%s\n",$domain,$class,$alias;
	}
      }

    }

    print ZONEFILE ";\n;\n; eof\n";
    close(ZONEFILE);
  }

  print BINDFILE "\n\n// eof\n";
  close(BINDFILE);
}


######################################################################
# DHCP

sub make_dhcp() {
  print "DHCP configuration\n";
  $time_now = gmtime;

  # dhcpd.conf
  print "Generating dhcpd.conf...\n";

  
  open(DHCPFILE,">dhcpd.conf") || fatal("Cannot create dhcpd.conf!");
  print DHCPFILE "# dhcpd.conf -- automagically generated using $0 $VER\n";
  print DHCPFILE "#               created by $user at $time_now\n#\n";

  # global entries
  undef @q;
  db_query("SELECT d.dhcp FROM dhcp_entries d " .
	   "WHERE d.type=1 AND d.ref=$serverid;",\@q);
  for $ i (0..$#q) {
    print DHCPFILE "$q[$i][0];\n";
  }
  print DHCPFILE "\n\n";

  # subnet map
  print DHCPFILE "shared-network \"$servername\" {\n";
  
  undef @subnets;
  undef @nets;
  db_query("SELECT net FROM nets WHERE server=$serverid AND no_dhcp=false " .
	   "AND subnet=false ORDER BY net;",\@nets);
  if (@nets < 1) {
    fatal("No nets, that use DHCP, defined for this server!");
  }
  for $i (0 .. $#nets) {
    $net=$nets[$i][0];
    print DHCPFILE "# net: $net\n\n";
    undef @q;
    db_query("SELECT net,id,name FROM nets " .
	     "WHERE server=$serverid AND no_dhcp=false AND subnet=true " .
	     "AND net << '$net' ORDER BY net;",\@q);
    if (@q < 1 ) {
      error("No subnets that use DHCP found");
      push @q, [$net,'',''];
    } else {
      undef @qq;
      db_query("SELECT ip,router FROM hosts,zones,rr_a " .
	       "WHERE hosts.zone=zones.id AND rr_a.host=hosts.id " .
	       "AND zones.server=$serverid AND router>0 " .
	       "AND ip << '$net' " .
	       "ORDER BY ip,router;",\@qq);
      warn("No router interfaces found for net $net!") if (@qq < 1);

      for $j (0 .. $#q) {
	$ssnet = new Net::Netmask($q[$j][0]);
	$snet = $ssnet->base();
        $nmask = $ssnet->mask();
	$dhcpid = $q[$j][1];
	print DHCPFILE "\t# $q[$j][2]\n";
	print DHCPFILE "\tsubnet $snet netmask $nmask {\n";

	$pri=999999; # should be enough 'cos priority range for a router 0-999
	$router='';
	for $k (0 .. $#qq) {
	  if ($ssnet->match($qq[$k][0]) && $pri > $qq[$k][1]) {
	    $pri=$qq[$k][1];
	    $router=$qq[$k][0];
	  }
	}
	unless ($router eq '') {
	  $router =~ s/\/\d{1,2}\s*$//g;
	  print DHCPFILE "\t\toption routers $router;\n";
	} else {
	  print "no router interface found for subnet: $snet $nmask\n";
	}

	undef @qqq;
	db_query("SELECT d.dhcp FROM dhcp_entries d " .
		 "WHERE d.type=4 AND d.ref=$dhcpid;",\@qqq);
	for $k (0..$#qqq) {
	  print DHCPFILE "\t\t$qqq[$k][0];\n";
	}

	print DHCPFILE "\t}\n";
      }
    }

  }
  print DHCPFILE "}\n\n";

  # groups
  print DHCPFILE "# groups\n\n";

  undef @groups;
  db_query("SELECT id,name FROM groups WHERE server=$serverid;",\@groups);
  if (@groups < 1) {
    error("no groups found for this server");
  } 
  else {
    undef @ghosts;
    db_query("SELECT h.grp,h.ether,a.ip,h.domain,z.name,h.id " .
	     "FROM hosts h, zones z, rr_a a " .
	     "WHERE h.zone=z.id AND a.host=h.id AND h.type=1 " .
	     "AND h.ether NOTNULL AND z.server=$serverid AND a.forward=true " .
	     "AND h.grp>-1 " .
	     "ORDER BY a.ip;",\@ghosts);
    if (@ghosts > 0) {
      for $i (0.. $#groups) {
	$gid=$groups[$i][0];
	$group=$groups[$i][1];
	# $dhcp=db_decode_list_str($groups[$i][2]);
	print DHCPFILE "group {  # $group\n";
	undef @qqq;
	db_query("SELECT d.dhcp FROM dhcp_entries d " .
		 "WHERE d.type=5 AND d.ref=$gid;",\@qqq);
	for $k (0..$#qqq) {
	  $qqq[$k][0] =~ s/\\"/"/g;
	  print DHCPFILE "\t$qqq[$k][0];\n";
	}
	print DHCPFILE "\t\n";

	for $j (0 .. $#nets) {
	  $net=new Net::Netmask($nets[$j][0]);
	  print DHCPFILE "\t# net: " .$net->desc() . "\n";
	  for $k (0 .. $#ghosts) {
	    if ($ghosts[$k][0]==$gid && $net->match($ghosts[$k][2]) ) {
	      $host=$ghosts[$k][3];
	      $host.=".$ghosts[$k][4]" unless ($host =~ /\.$/);
	      $ip=$ghosts[$k][2];
	      $ip =~ s/\/\d{1,2}\s*$//g;
	      $ether=dhcpether($ghosts[$k][1]);
	      #$dhcp=db_decode_list_str($ghosts[$k][5]);
	      $dhcpid=$ghosts[$k][5];
	      if ($ethers{$ether}>0) {
		error("dublicate interface $ip for $ether ($host) ignored");
		next;
	      }
	      $ethers{$ether}++;
	      print DHCPFILE "\thost $host {\n";
	      print DHCPFILE "\t\tfixed-address $ip;\n";
	      print DHCPFILE "\t\thardware ethernet $ether;\n";
	      undef @qqq;
	      db_query("SELECT d.dhcp FROM dhcp_entries d " .
		       "WHERE d.type=3 AND d.ref=$dhcpid;",\@qqq);
	      for $l (0..$#qqq) {
		$qqq[$l][0] =~ s/\\"/"/g;
		print DHCPFILE "\t\t$qqq[$l][0];\n";
	      }
	      print DHCPFILE "\t}\n";
	    }
	  }
	}
	print DHCPFILE "}\n\n";
      }
    } else {
      print "no hosts found for any groups!";
    }
    }

  # not grouped hosts...
  print DHCPFILE "\n# hosts not in any group\n\n";
  undef @ghosts;
  db_query("SELECT h.grp,h.ether,a.ip,h.domain,z.name,h.id " .
	   "FROM hosts h, zones z, rr_a a " .
	   "WHERE h.zone=z.id AND a.host=h.id AND h.type=1 " .
	   "AND h.ether NOTNULL AND z.server=$serverid AND a.forward=true " .
	   "AND h.grp<0 " .
	   "ORDER BY a.ip;",\@ghosts);
  if (@ghosts > 0 ) {
    for $j (0 .. $#nets) {
      $net=new Net::Netmask($nets[$j][0]);
      print DHCPFILE "# net: " .$net->desc() . "\n";
      for $k (0 .. $#ghosts) {
	if ($net->match($ghosts[$k][2]) ) {
	  $host=$ghosts[$k][3];
	  $host.=".$ghosts[$k][4]" unless ($host =~ /\.$/);
	  $ip=$ghosts[$k][2];
	  $ip =~ s/\/\d{1,2}\s*$//g;
	  $ether=dhcpether($ghosts[$k][1]);
	  #$dhcp=db_decode_list_str($ghosts[$k][5]);
	  $dhcpid=$ghosts[$k][5];
	  if ($ethers{$ether}>0) {
	    error("dublicate interface $ip for $ether ($host) ignored");
	    next;
	  }
	  $ethers{$ether}++;
	  print DHCPFILE "host $host {\n";
	  print DHCPFILE "\tfixed-address $ip;\n";
	  print DHCPFILE "\thardware ethernet $ether;\n";
	  undef @qqq;
	  db_query("SELECT d.dhcp FROM dhcp_entries d " .
		       "WHERE d.type=3 AND d.ref=$dhcpid;",\@qqq);
	  for $l (0..$#qqq) {
	    $qqq[$l][0] =~ s/\\"/"/g;
	    print DHCPFILE "\t$qqq[$l][0];\n";
	  }
	  print DHCPFILE "}\n";
	}
      }
    }
  }

  undef @ghosts;
  undef %ethers;
  print DHCPFILE "\n# eof\n";
  close(DHCPFILE);
}


######################################################################
# printcap

sub make_printcap() {
  print "PRINTER configuration\n";
  $time_now = gmtime;

  # printcap
  print "Generating printcap...\n";

  
  open(PCAPFILE,">printcap") || fatal("Cannot create printcap!");
  print PCAPFILE "# printcap -- automagically generated using $0 $VER\n";
  print PCAPFILE "#             created by $user at $time_now\n#\n";


  print PCAPFILE "# eof\n";
  close(PCAPFILE);
}


############################################################################

sub dhcpether($) {
  my ($e) = @_;

  $e="\L$e";
  if ($e =~ /(..)(..)(..)(..)(..)(..)/) {
    return "$1:$2:$3:$4:$5:$6";
  }

  return "00:00:00:00:00:00";
}

sub error($) {
  my ($msg) = @_;

  print STDERR "$0: $msg\n";
}

sub fatal($) {
  my ($msg) = @_;
  error($msg);
  exit 1;
}




